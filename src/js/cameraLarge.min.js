! function(e) {
    function t(r) {
        if (n[r]) return n[r].exports;
        var i = n[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return e[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports
    }
    var n = {};
    t.m = e, t.c = n, t.i = function(e) {
        return e
    }, t.d = function(e, n, r) {
        t.o(e, n) || Object.defineProperty(e, n, {
            configurable: !1,
            enumerable: !0,
            get: r
        })
    }, t.n = function(e) {
        var n = e && e.__esModule ? function() {
            return e.default
        } : function() {
            return e
        };
        return t.d(n, "a", n), n
    }, t.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, t.p = "", t(t.s = 1490)
}({
    1490: function(e, t, n) {
        n(923), e.exports = n(934)
    },
    23: function(e, t, n) {
        "use strict";
        var r = !0,
            i = {
                disableLog: function(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (r = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                },
                log: function() {
                    if ("object" == typeof window) {
                        if (r) return;
                        "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                    }
                },
                extractVersion: function(e, t, n) {
                    var r = e.match(t);
                    return r && r.length >= n && parseInt(r[n], 10)
                },
                detectBrowser: function() {
                    var e = {};
                    if (e.browser = null, e.version = null, "undefined" == typeof window || !window.navigator) return e.browser = "Not a browser.", e;
                    if (navigator.mozGetUserMedia) e.browser = "firefox", e.version = this.extractVersion(navigator.userAgent, /Firefox\/([0-9]+)\./, 1);
                    else if (navigator.webkitGetUserMedia)
                        if (window.webkitRTCPeerConnection) e.browser = "chrome", e.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\/([0-9]+)\./, 2);
                        else {
                            if (!navigator.userAgent.match(/Version\/(\d+).(\d+)/)) return e.browser = "Unsupported webkit-based browser with GUM support but no WebRTC support.", e;
                            e.browser = "safari", e.version = this.extractVersion(navigator.userAgent, /AppleWebKit\/([0-9]+)\./, 1)
                        }
                    else {
                        if (!navigator.mediaDevices || !navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) return e.browser = "Not a supported browser.", e;
                        e.browser = "edge", e.version = this.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2)
                    }
                    return e
                }
            };
        e.exports = {
            log: i.log,
            disableLog: i.disableLog,
            browserDetails: i.detectBrowser(),
            extractVersion: i.extractVersion
        }
    },
    27: function(e, t, n) {
        "use strict";
        var r = n(35),
            i = {
                POPUP_PATH: "popup.html",
                POPUP_PORT_NAME: "VIEWEDIT_POPUP_PORT",
                DEFAULT_TAG_ON_PLAYER_CREATION: r.a.PLAYER_TAG,
                Tabs: {
                    FEED: "feed",
                    LIBRARY: "library",
                    OPTIONS: "options"
                },
                MIN_UPLOAD_PARTS: 1,
                RELOAD_DELAY_IN_MS: 3e3,
                COUNTDOWN_LENGTH_IN_MS: 3e3,
                START_RECORDING_DELAY_MS: 250,
                MIN_RECORDING_TIME_MS: 2e3,
                TIMER_VISIBILITY_DELAY_IN_MS: 250,
                S3_TOKEN_MAX_AGE_IN_S: 2700,
                MIN_FRAME_RATE: 25,
                SMALL_VIDEO_HEIGHT: 240,
                SMALL_VIDEO_WIDTH: 320,
                VIDEO_HEIGHT: 720,
                VIDEO_WIDTH: 1280,
                MAX_EMPTY_BLOBS: 4,
                MAX_CONNECTION_FAILURES: 3,
                CONNECTION_CHECK_POLL_MILLISECONDS: 5e3,
                FREE_RECORDING_LIMIT_MILLISECONDS: 3600500,
                FIVE_MINUTES_WARNING_MILLISECONDS: 305e3,
                ONE_MINUTE_WARNING_MILLISECONDS: 65e3,
                LOCKED_ACCOUNT_CODE: 1021,
                GIF_LENGTH_MS: 3e3,
                GIF_START_MS: 0,
                CAMERA_OFF: "Camera Off",
                ORIGIN: "govideo_chrome_extension",
                MIC_OFF: "Mic Off",
                AccountType: {
                    FREE: "free",
                    ENTERPRISE: "enterprise"
                },
                Analytics: {
                    Sources: {
                        TIME_LIMIT_STOP: "time-limit-finish",
                        CONTROLS_STOP: "controls-stop",
                        COUNTDOWN_ABORT: "countdown-abort",
                        CAMERA_ONLY_CANCEL: "camera-only-cancel"
                    }
                },
                Features: [],
                EbertEvents: {
                    INSTALLED: "ViewedItInstalled",
                    LOGIN: "ViewedItLogin",
                    LOGOUT: "ViewedItLogout",
                    PROCESSING: "ViewedItProcessing"
                }
            };
        t.a = i
    },
    35: function(e, t, n) {
        "use strict";
        var r = void 0;
        r = {
            VIDEO_DESCRIPTION: "This video was created with cincopa GoVideo. https://www.cincopa.com/govideo",
            TAG_NAME: "cincopa GoVideo",
            RECORDING_NAME: "cincopa Recording",
            PUSH_NOTIFICATION_DESCRIPTION: "Open cincopa GoVideo to see more...",
            ONBOARDING_TOOL_TIP: "Try out cincopa GoVideo! Click on the V-Bot icon to insert your videos right in your compose window!",
            GMAIL_NO_VIDEOS_MESSAGE: "Record a video using cincopa GoVideo to use this feature",
            GMAIL_VIEWEDIT_BUTTON_TITLE: "Insert cincopa Videos",
            SIGN_OUT: "Sign Out",
            AUTHENTICATOR_PROMPT: "You're one step away from making great videos",
            UPDATE_TITLE: "Update available",
            UPDATE_AVAILABLE: "Weâ€™ve updated the app to improve your experience. Enjoy!",
            UPDATE_BUTTON: "Update Now",
            DELETE_ERROR: "This video is used multiple times and we cannot delete it. Please contact govideosupport@cincopa.com for help.",
            RELOAD_PROMPT: "Having problems? Try reloading cincopa GoVideo!",
            SUPPORT_EMAIL: "govideosupport@cincopa.com",
            MAILTO_SUPPORT: "mailto:govideosupport@cincopa.com",
            PLAYER_TAG: "Created by cincopa GoVideo",
            CAMONLY_COUNTDOWN_IMG_POSITION: "2.5",
            COUNTDOWN_IMG_POSITION: "20",
            BLOCKED_ACCOUNT: "blocked-account-cincopa.svg",
            ENABLE_PERMISSIONS: "enable-permissions-cincopa.gif",
            LOGO_WELCOME: "cincopa-GoVideo-logo.png",
            LOGO_TEXT: "logo-cincopa-text.svg",
            UNBLOCK_CAM: "unblock-cam-cincopa.gif",
            UNBLOCK_MIC: "unblock-mic-cincopa.gif",
            HELPER_GMAIL: "vbot-gmail.png",
            COUNTDOWN_IMAGE: "vbot.svg"
        }, t.a = r
    },
    672: function(e, t, n) {
        "use strict";
        var r = {};
        r.generateIdentifier = function() {
            return Math.random().toString(36).substr(2, 10)
        }, r.localCName = r.generateIdentifier(), r.splitLines = function(e) {
            return e.trim().split("\n").map(function(e) {
                return e.trim()
            })
        }, r.splitSections = function(e) {
            return e.split("\nm=").map(function(e, t) {
                return (t > 0 ? "m=" + e : e).trim() + "\r\n"
            })
        }, r.matchPrefix = function(e, t) {
            return r.splitLines(e).filter(function(e) {
                return 0 === e.indexOf(t)
            })
        }, r.parseCandidate = function(e) {
            var t;
            t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
            for (var n = {
                foundation: t[0],
                component: t[1],
                protocol: t[2].toLowerCase(),
                priority: parseInt(t[3], 10),
                ip: t[4],
                port: parseInt(t[5], 10),
                type: t[7]
            }, r = 8; r < t.length; r += 2) switch (t[r]) {
                case "raddr":
                    n.relatedAddress = t[r + 1];
                    break;
                case "rport":
                    n.relatedPort = parseInt(t[r + 1], 10);
                    break;
                case "tcptype":
                    n.tcpType = t[r + 1];
                    break;
                default:
                    n[t[r]] = t[r + 1]
            }
            return n
        }, r.writeCandidate = function(e) {
            var t = [];
            t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.ip), t.push(e.port);
            var n = e.type;
            return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), "candidate:" + t.join(" ")
        }, r.parseIceOptions = function(e) {
            return e.substr(14).split(" ")
        }, r.parseRtpMap = function(e) {
            var t = e.substr(9).split(" "),
                n = {
                    payloadType: parseInt(t.shift(), 10)
                };
            return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.numChannels = 3 === t.length ? parseInt(t[2], 10) : 1, n
        }, r.writeRtpMap = function(e) {
            var t = e.payloadType;
            return void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType), "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== e.numChannels ? "/" + e.numChannels : "") + "\r\n"
        }, r.parseExtmap = function(e) {
            var t = e.substr(9).split(" ");
            return {
                id: parseInt(t[0], 10),
                direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                uri: t[1]
            }
        }, r.writeExtmap = function(e) {
            return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
        }, r.parseFmtp = function(e) {
            for (var t, n = {}, r = e.substr(e.indexOf(" ") + 1).split(";"), i = 0; i < r.length; i++) t = r[i].trim().split("="), n[t[0].trim()] = t[1];
            return n
        }, r.writeFmtp = function(e) {
            var t = "",
                n = e.payloadType;
            if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                var r = [];
                Object.keys(e.parameters).forEach(function(t) {
                    r.push(t + "=" + e.parameters[t])
                }), t += "a=fmtp:" + n + " " + r.join(";") + "\r\n"
            }
            return t
        }, r.parseRtcpFb = function(e) {
            var t = e.substr(e.indexOf(" ") + 1).split(" ");
            return {
                type: t.shift(),
                parameter: t.join(" ")
            }
        }, r.writeRtcpFb = function(e) {
            var t = "",
                n = e.payloadType;
            return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(e) {
                t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
            }), t
        }, r.parseSsrcMedia = function(e) {
            var t = e.indexOf(" "),
                n = {
                    ssrc: parseInt(e.substr(7, t - 7), 10)
                },
                r = e.indexOf(":", t);
            return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n
        }, r.getMid = function(e) {
            var t = r.matchPrefix(e, "a=mid:")[0];
            if (t) return t.substr(6)
        }, r.parseFingerprint = function(e) {
            var t = e.substr(14).split(" ");
            return {
                algorithm: t[0].toLowerCase(),
                value: t[1]
            }
        }, r.getDtlsParameters = function(e, t) {
            return {
                role: "auto",
                fingerprints: r.matchPrefix(e + t, "a=fingerprint:").map(r.parseFingerprint)
            }
        }, r.writeDtlsParameters = function(e, t) {
            var n = "a=setup:" + t + "\r\n";
            return e.fingerprints.forEach(function(e) {
                n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
            }), n
        }, r.getIceParameters = function(e, t) {
            var n = r.splitLines(e);
            return n = n.concat(r.splitLines(t)), {
                usernameFragment: n.filter(function(e) {
                    return 0 === e.indexOf("a=ice-ufrag:")
                })[0].substr(12),
                password: n.filter(function(e) {
                    return 0 === e.indexOf("a=ice-pwd:")
                })[0].substr(10)
            }
        }, r.writeIceParameters = function(e) {
            return "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"
        }, r.parseRtpParameters = function(e) {
            for (var t = {
                codecs: [],
                headerExtensions: [],
                fecMechanisms: [],
                rtcp: []
            }, n = r.splitLines(e), i = n[0].split(" "), a = 3; a < i.length; a++) {
                var o = i[a],
                    s = r.matchPrefix(e, "a=rtpmap:" + o + " ")[0];
                if (s) {
                    var c = r.parseRtpMap(s),
                        d = r.matchPrefix(e, "a=fmtp:" + o + " ");
                    switch (c.parameters = d.length ? r.parseFmtp(d[0]) : {}, c.rtcpFeedback = r.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(r.parseRtcpFb), t.codecs.push(c), c.name.toUpperCase()) {
                        case "RED":
                        case "ULPFEC":
                            t.fecMechanisms.push(c.name.toUpperCase())
                    }
                }
            }
            return r.matchPrefix(e, "a=extmap:").forEach(function(e) {
                t.headerExtensions.push(r.parseExtmap(e))
            }), t
        }, r.writeRtpDescription = function(e, t) {
            var n = "";
            n += "m=" + e + " ", n += t.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += t.codecs.map(function(e) {
                return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType
            }).join(" ") + "\r\n", n += "c=IN IP4 0.0.0.0\r\n", n += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach(function(e) {
                n += r.writeRtpMap(e), n += r.writeFmtp(e), n += r.writeRtcpFb(e)
            });
            var i = 0;
            return t.codecs.forEach(function(e) {
                e.maxptime > i && (i = e.maxptime)
            }), i > 0 && (n += "a=maxptime:" + i + "\r\n"), n += "a=rtcp-mux\r\n", t.headerExtensions.forEach(function(e) {
                n += r.writeExtmap(e)
            }), n
        }, r.parseRtpEncodingParameters = function(e) {
            var t, n = [],
                i = r.parseRtpParameters(e),
                a = -1 !== i.fecMechanisms.indexOf("RED"),
                o = -1 !== i.fecMechanisms.indexOf("ULPFEC"),
                s = r.matchPrefix(e, "a=ssrc:").map(function(e) {
                    return r.parseSsrcMedia(e)
                }).filter(function(e) {
                    return "cname" === e.attribute
                }),
                c = s.length > 0 && s[0].ssrc,
                d = r.matchPrefix(e, "a=ssrc-group:FID").map(function(e) {
                    var t = e.split(" ");
                    return t.shift(), t.map(function(e) {
                        return parseInt(e, 10)
                    })
                });
            d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), i.codecs.forEach(function(e) {
                if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                    var r = {
                        ssrc: c,
                        codecPayloadType: parseInt(e.parameters.apt, 10),
                        rtx: {
                            ssrc: t
                        }
                    };
                    n.push(r), a && (r = JSON.parse(JSON.stringify(r)), r.fec = {
                        ssrc: t,
                        mechanism: o ? "red+ulpfec" : "red"
                    }, n.push(r))
                }
            }), 0 === n.length && c && n.push({
                ssrc: c
            });
            var p = r.matchPrefix(e, "b=");
            return p.length && (0 === p[0].indexOf("b=TIAS:") ? p = parseInt(p[0].substr(7), 10) : 0 === p[0].indexOf("b=AS:") && (p = parseInt(p[0].substr(5), 10)), n.forEach(function(e) {
                e.maxBitrate = p
            })), n
        }, r.parseRtcpParameters = function(e) {
            var t = {},
                n = r.matchPrefix(e, "a=ssrc:").map(function(e) {
                    return r.parseSsrcMedia(e)
                }).filter(function(e) {
                    return "cname" === e.attribute
                })[0];
            n && (t.cname = n.value, t.ssrc = n.ssrc);
            var i = r.matchPrefix(e, "a=rtcp-rsize");
            t.reducedSize = i.length > 0, t.compound = 0 === i.length;
            var a = r.matchPrefix(e, "a=rtcp-mux");
            return t.mux = a.length > 0, t
        }, r.parseMsid = function(e) {
            var t, n = r.matchPrefix(e, "a=msid:");
            if (1 === n.length) return t = n[0].substr(7).split(" "), {
                stream: t[0],
                track: t[1]
            };
            var i = r.matchPrefix(e, "a=ssrc:").map(function(e) {
                return r.parseSsrcMedia(e)
            }).filter(function(e) {
                return "msid" === e.attribute
            });
            return i.length > 0 ? (t = i[0].value.split(" "), {
                stream: t[0],
                track: t[1]
            }) : void 0
        }, r.writeSessionBoilerplate = function() {
            return "v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        }, r.writeMediaSection = function(e, t, n, i) {
            var a = r.writeRtpDescription(e.kind, t);
            if (a += r.writeIceParameters(e.iceGatherer.getLocalParameters()), a += r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === n ? "actpass" : "active"), a += "a=mid:" + e.mid + "\r\n", e.direction ? a += "a=" + e.direction + "\r\n" : e.rtpSender && e.rtpReceiver ? a += "a=sendrecv\r\n" : e.rtpSender ? a += "a=sendonly\r\n" : e.rtpReceiver ? a += "a=recvonly\r\n" : a += "a=inactive\r\n", e.rtpSender) {
                var o = "msid:" + i.id + " " + e.rtpSender.track.id + "\r\n";
                a += "a=" + o, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + o, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + o, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + r.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + r.localCName + "\r\n"), a
        }, r.getDirection = function(e, t) {
            for (var n = r.splitLines(e), i = 0; i < n.length; i++) switch (n[i]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                    return n[i].substr(2)
            }
            return t ? r.getDirection(t) : "sendrecv"
        }, r.getKind = function(e) {
            return r.splitLines(e)[0].split(" ")[0].substr(2)
        }, r.isRejected = function(e) {
            return "0" === e.split(" ", 2)[1]
        }, e.exports = r
    },
    682: function(e, t, n) {
        "use strict";
        ! function() {
            var t = n(23).log,
                r = n(23).browserDetails;
            e.exports.browserDetails = r, e.exports.extractVersion = n(23).extractVersion, e.exports.disableLog = n(23).disableLog;
            var i = n(683) || null,
                a = n(685) || null,
                o = n(687) || null,
                s = n(689) || null;
            switch (r.browser) {
                case "opera":
                case "chrome":
                    if (!i || !i.shimPeerConnection) return void t("Chrome shim is not included in this adapter release.");
                    t("adapter.js shimming chrome."), e.exports.browserShim = i, i.shimGetUserMedia(), i.shimMediaStream(), i.shimSourceObject(), i.shimPeerConnection(), i.shimOnTrack();
                    break;
                case "firefox":
                    if (!o || !o.shimPeerConnection) return void t("Firefox shim is not included in this adapter release.");
                    t("adapter.js shimming firefox."), e.exports.browserShim = o, o.shimGetUserMedia(), o.shimSourceObject(), o.shimPeerConnection(), o.shimOnTrack();
                    break;
                case "edge":
                    if (!a || !a.shimPeerConnection) return void t("MS edge shim is not included in this adapter release.");
                    t("adapter.js shimming edge."), e.exports.browserShim = a, a.shimGetUserMedia(), a.shimPeerConnection();
                    break;
                case "safari":
                    if (!s) return void t("Safari shim is not included in this adapter release.");
                    t("adapter.js shimming safari."), e.exports.browserShim = s, s.shimGetUserMedia();
                    break;
                default:
                    t("Unsupported browser!")
            }
        }()
    },
    683: function(e, t, n) {
        "use strict";
        var r = n(23).log,
            i = n(23).browserDetails,
            a = {
                shimMediaStream: function() {
                    window.MediaStream = window.MediaStream || window.webkitMediaStream
                },
                shimOnTrack: function() {
                    "object" != typeof window || !window.RTCPeerConnection || "ontrack" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
                        get: function() {
                            return this._ontrack
                        },
                        set: function(e) {
                            var t = this;
                            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e), this.addEventListener("addstream", this._ontrackpoly = function(e) {
                                e.stream.addEventListener("addtrack", function(n) {
                                    var r = new Event("track");
                                    r.track = n.track, r.receiver = {
                                        track: n.track
                                    }, r.streams = [e.stream], t.dispatchEvent(r)
                                }), e.stream.getTracks().forEach(function(t) {
                                    var n = new Event("track");
                                    n.track = t, n.receiver = {
                                        track: t
                                    }, n.streams = [e.stream], this.dispatchEvent(n)
                                }.bind(this))
                            }.bind(this))
                        }
                    })
                },
                shimSourceObject: function() {
                    "object" == typeof window && (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this._srcObject
                        },
                        set: function(e) {
                            var t = this;
                            if (this._srcObject = e, this.src && URL.revokeObjectURL(this.src), !e) return void(this.src = "");
                            this.src = URL.createObjectURL(e), e.addEventListener("addtrack", function() {
                                t.src && URL.revokeObjectURL(t.src), t.src = URL.createObjectURL(e)
                            }), e.addEventListener("removetrack", function() {
                                t.src && URL.revokeObjectURL(t.src), t.src = URL.createObjectURL(e)
                            })
                        }
                    }))
                },
                shimPeerConnection: function() {
                    window.RTCPeerConnection = function(e, t) {
                        r("PeerConnection"), e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy);
                        var n = new webkitRTCPeerConnection(e, t),
                            i = n.getStats.bind(n);
                        return n.getStats = function(e, t, n) {
                            var r = this,
                                a = arguments;
                            if (arguments.length > 0 && "function" == typeof e) return i(e, t);
                            var o = function(e) {
                                    var t = {};
                                    return e.result().forEach(function(e) {
                                        var n = {
                                            id: e.id,
                                            timestamp: e.timestamp,
                                            type: e.type
                                        };
                                        e.names().forEach(function(t) {
                                            n[t] = e.stat(t)
                                        }), t[n.id] = n
                                    }), t
                                },
                                s = function(e, t) {
                                    var n = new Map(Object.keys(e).map(function(t) {
                                        return [t, e[t]]
                                    }));
                                    return t = t || e, Object.keys(t).forEach(function(e) {
                                        n[e] = t[e]
                                    }), n
                                };
                            if (arguments.length >= 2) {
                                var c = function(e) {
                                    a[1](s(o(e)))
                                };
                                return i.apply(this, [c, arguments[0]])
                            }
                            return new Promise(function(t, n) {
                                1 === a.length && "object" == typeof e ? i.apply(r, [function(e) {
                                    t(s(o(e)))
                                }, n]) : i.apply(r, [function(e) {
                                    t(s(o(e), e.result()))
                                }, n])
                            }).then(t, n)
                        }, n
                    }, window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype, webkitRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
                        get: function() {
                            return webkitRTCPeerConnection.generateCertificate
                        }
                    }), ["createOffer", "createAnswer"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            var e = this;
                            if (arguments.length < 1 || 1 === arguments.length && "object" == typeof arguments[0]) {
                                var n = 1 === arguments.length ? arguments[0] : void 0;
                                return new Promise(function(r, i) {
                                    t.apply(e, [r, i, n])
                                })
                            }
                            return t.apply(this, arguments)
                        }
                    }), i.version < 51 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            var e = arguments,
                                n = this,
                                r = new Promise(function(r, i) {
                                    t.apply(n, [e[0], r, i])
                                });
                            return e.length < 2 ? r : r.then(function() {
                                e[1].apply(null, [])
                            }, function(t) {
                                e.length >= 3 && e[2].apply(null, [t])
                            })
                        }
                    }), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            return arguments[0] = new("addIceCandidate" === e ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments)
                        }
                    });
                    var e = RTCPeerConnection.prototype.addIceCandidate;
                    RTCPeerConnection.prototype.addIceCandidate = function() {
                        return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                    }
                }
            };
        e.exports = {
            shimMediaStream: a.shimMediaStream,
            shimOnTrack: a.shimOnTrack,
            shimSourceObject: a.shimSourceObject,
            shimPeerConnection: a.shimPeerConnection,
            shimGetUserMedia: n(684)
        }
    },
    684: function(e, t, n) {
        "use strict";
        var r = n(23).log;
        e.exports = function() {
            var e = function(e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    var t = {};
                    return Object.keys(e).forEach(function(n) {
                        if ("require" !== n && "advanced" !== n && "mediaSource" !== n ) {
                            var r = "object" == typeof e[n] ? e[n] : {
                                ideal: e[n],
                            };
                            r = r || {};
                            void 0 !== r.exact && "number" == typeof r.exact && (r.min = r.max = r.exact);
                            var i = function(e, t) {
                                return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                            };
                            if (void 0 !== r.ideal) {
                                t.optional = t.optional || [];
                                var a = {};
                                "number" == typeof r.ideal ? (a[i("min", n)] = r.ideal, t.optional.push(a), a = {}, a[i("max", n)] = r.ideal, t.optional.push(a)) : (a[i("", n)] = r.ideal, t.optional.push(a))
                            }
                            void 0 !== r.exact && "number" != typeof r.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[i("", n)] = r.exact) : ["min", "max"].forEach(function(e) {
                                void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, n)] = r[e])
                            })
                        }
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                t = function(t, n) {
                    if (t = JSON.parse(JSON.stringify(t)), t && t.audio && (t.audio = e(t.audio)), t && "object" == typeof t.video) {
                        var i = t.video.facingMode;
                        if ((i = i && ("object" == typeof i ? i : {
                                ideal: i
                            })) && ("user" === i.exact || "environment" === i.exact || "user" === i.ideal || "environment" === i.ideal) && (!navigator.mediaDevices.getSupportedConstraints || !navigator.mediaDevices.getSupportedConstraints().facingMode) && (delete t.video.facingMode, "environment" === i.exact || "environment" === i.ideal)) return navigator.mediaDevices.enumerateDevices().then(function(a) {
                            a = a.filter(function(e) {
                                return "videoinput" === e.kind
                            });
                            var o = a.find(function(e) {
                                return -1 !== e.label.toLowerCase().indexOf("back")
                            }) || a.length && a[a.length - 1];
                            return o && (t.video.deviceId = i.exact ? {
                                exact: o.deviceId
                            } : {
                                ideal: o.deviceId
                            }), t.video = e(t.video), r("chrome: " + JSON.stringify(t)), n(t)
                        });
                        t.video = e(t.video)
                    }
                    return r("chrome: " + JSON.stringify(t)), n(t)
                },
                n = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            ConstraintNotSatisfiedError: "OverconstrainedError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraintName,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                },
                i = function(e, r, i) {
                    t(e, function(e) {
                        navigator.webkitGetUserMedia(e, r, function(e) {
                            i(n(e))
                        })
                    })
                };
            navigator.getUserMedia = i;
            var a = function(e) {
                return new Promise(function(t, n) {
                    navigator.getUserMedia(e, t, n)
                })
            };
            if (navigator.mediaDevices || (navigator.mediaDevices = {
                    getUserMedia: a,
                    enumerateDevices: function() {
                        return new Promise(function(e) {
                            var t = {
                                audio: "audioinput",
                                video: "videoinput"
                            };
                            return MediaStreamTrack.getSources(function(n) {
                                e(n.map(function(e) {
                                    return {
                                        label: e.label,
                                        kind: t[e.kind],
                                        deviceId: e.id,
                                        groupId: ""
                                    }
                                }))
                            })
                        })
                    }
                }), navigator.mediaDevices.getUserMedia) {
                var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(e) {
                    return t(e, function(e) {
                        return o(e).then(function(t) {
                            if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(function(e) {
                                e.stop()
                            }), new DOMException("", "NotFoundError");
                            return t
                        }, function(e) {
                            return Promise.reject(n(e))
                        })
                    })
                }
            } else navigator.mediaDevices.getUserMedia = function(e) {
                return a(e)
            };
            void 0 === navigator.mediaDevices.addEventListener && (navigator.mediaDevices.addEventListener = function() {
                r("Dummy mediaDevices.addEventListener called.")
            }), void 0 === navigator.mediaDevices.removeEventListener && (navigator.mediaDevices.removeEventListener = function() {
                r("Dummy mediaDevices.removeEventListener called.")
            })
        }
    },
    685: function(e, t, n) {
        "use strict";
        var r = n(672),
            i = n(23).browserDetails,
            a = {
                shimPeerConnection: function() {
                    if (window.RTCIceGatherer) {
                        window.RTCIceCandidate || (window.RTCIceCandidate = function(e) {
                            return e
                        }), window.RTCSessionDescription || (window.RTCSessionDescription = function(e) {
                            return e
                        });
                        var e = Object.getOwnPropertyDescriptor(MediaStreamTrack.prototype, "enabled");
                        Object.defineProperty(MediaStreamTrack.prototype, "enabled", {
                            set: function(t) {
                                e.set.call(this, t);
                                var n = new Event("enabled");
                                n.enabled = t, this.dispatchEvent(n)
                            }
                        })
                    }
                    window.RTCPeerConnection = function(e) {
                        var t = this,
                            n = document.createDocumentFragment();
                        if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(e) {
                                t[e] = n[e].bind(n)
                            }), this.onicecandidate = null, this.onaddstream = null, this.ontrack = null, this.onremovestream = null, this.onsignalingstatechange = null, this.oniceconnectionstatechange = null, this.onnegotiationneeded = null, this.ondatachannel = null, this.localStreams = [], this.remoteStreams = [], this.getLocalStreams = function() {
                                return t.localStreams
                            }, this.getRemoteStreams = function() {
                                return t.remoteStreams
                            }, this.localDescription = new RTCSessionDescription({
                                type: "",
                                sdp: ""
                            }), this.remoteDescription = new RTCSessionDescription({
                                type: "",
                                sdp: ""
                            }), this.signalingState = "stable", this.iceConnectionState = "new", this.iceGatheringState = "new", this.iceOptions = {
                                gatherPolicy: "all",
                                iceServers: []
                            }, e && e.iceTransportPolicy) switch (e.iceTransportPolicy) {
                            case "all":
                            case "relay":
                                this.iceOptions.gatherPolicy = e.iceTransportPolicy;
                                break;
                            case "none":
                                throw new TypeError('iceTransportPolicy "none" not supported')
                        }
                        if (this.usingBundle = e && "max-bundle" === e.bundlePolicy, e && e.iceServers) {
                            var r = JSON.parse(JSON.stringify(e.iceServers));
                            this.iceOptions.iceServers = r.filter(function(e) {
                                if (e && e.urls) {
                                    var t = e.urls;
                                    return "string" == typeof t && (t = [t]), !!(t = t.filter(function(e) {
                                        return 0 === e.indexOf("turn:") && -1 !== e.indexOf("transport=udp") && -1 === e.indexOf("turn:[") || 0 === e.indexOf("stun:") && i.version >= 14393
                                    })[0])
                                }
                                return !1
                            })
                        }
                        this._config = e, this.transceivers = [], this._localIceCandidatesBuffer = []
                    }, window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
                        var e = this,
                            t = r.splitSections(e.localDescription.sdp);
                        this._localIceCandidatesBuffer.forEach(function(n) {
                            if (n.candidate && 0 !== Object.keys(n.candidate).length) - 1 === n.candidate.candidate.indexOf("typ endOfCandidates") && (t[n.candidate.sdpMLineIndex + 1] += "a=" + n.candidate.candidate + "\r\n");
                            else
                                for (var r = 1; r < t.length; r++) - 1 === t[r].indexOf("\r\na=end-of-candidates\r\n") && (t[r] += "a=end-of-candidates\r\n");
                            if (e.localDescription.sdp = t.join(""), e.dispatchEvent(n), null !== e.onicecandidate && e.onicecandidate(n), !n.candidate && "complete" !== e.iceGatheringState) {
                                e.transceivers.every(function(e) {
                                    return e.iceGatherer && "completed" === e.iceGatherer.state
                                }) && (e.iceGatheringState = "complete")
                            }
                        }), this._localIceCandidatesBuffer = []
                    }, window.RTCPeerConnection.prototype.getConfiguration = function() {
                        return this._config
                    }, window.RTCPeerConnection.prototype.addStream = function(e) {
                        var t = e.clone();
                        e.getTracks().forEach(function(e, n) {
                            var r = t.getTracks()[n];
                            e.addEventListener("enabled", function(e) {
                                r.enabled = e.enabled
                            })
                        }), this.localStreams.push(t), this._maybeFireNegotiationNeeded()
                    }, window.RTCPeerConnection.prototype.removeStream = function(e) {
                        var t = this.localStreams.indexOf(e);
                        t > -1 && (this.localStreams.splice(t, 1), this._maybeFireNegotiationNeeded())
                    }, window.RTCPeerConnection.prototype.getSenders = function() {
                        return this.transceivers.filter(function(e) {
                            return !!e.rtpSender
                        }).map(function(e) {
                            return e.rtpSender
                        })
                    }, window.RTCPeerConnection.prototype.getReceivers = function() {
                        return this.transceivers.filter(function(e) {
                            return !!e.rtpReceiver
                        }).map(function(e) {
                            return e.rtpReceiver
                        })
                    }, window.RTCPeerConnection.prototype._getCommonCapabilities = function(e, t) {
                        var n = {
                            codecs: [],
                            headerExtensions: [],
                            fecMechanisms: []
                        };
                        return e.codecs.forEach(function(e) {
                            for (var r = 0; r < t.codecs.length; r++) {
                                var i = t.codecs[r];
                                if (e.name.toLowerCase() === i.name.toLowerCase() && e.clockRate === i.clockRate) {
                                    i.numChannels = Math.min(e.numChannels, i.numChannels), n.codecs.push(i), i.rtcpFeedback = i.rtcpFeedback.filter(function(t) {
                                        for (var n = 0; n < e.rtcpFeedback.length; n++)
                                            if (e.rtcpFeedback[n].type === t.type && e.rtcpFeedback[n].parameter === t.parameter) return !0;
                                        return !1
                                    });
                                    break
                                }
                            }
                        }), e.headerExtensions.forEach(function(e) {
                            for (var r = 0; r < t.headerExtensions.length; r++) {
                                var i = t.headerExtensions[r];
                                if (e.uri === i.uri) {
                                    n.headerExtensions.push(i);
                                    break
                                }
                            }
                        }), n
                    }, window.RTCPeerConnection.prototype._createIceAndDtlsTransports = function(e, t) {
                        var n = this,
                            i = new RTCIceGatherer(n.iceOptions),
                            a = new RTCIceTransport(i);
                        i.onlocalcandidate = function(o) {
                            var s = new Event("icecandidate");
                            s.candidate = {
                                sdpMid: e,
                                sdpMLineIndex: t
                            };
                            var c = o.candidate,
                                d = !c || 0 === Object.keys(c).length;
                            d ? (void 0 === i.state && (i.state = "completed"), s.candidate.candidate = "candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates") : (c.component = "RTCP" === a.component ? 2 : 1, s.candidate.candidate = r.writeCandidate(c));
                            var p = r.splitSections(n.localDescription.sdp); - 1 === s.candidate.candidate.indexOf("typ endOfCandidates") ? p[s.candidate.sdpMLineIndex + 1] += "a=" + s.candidate.candidate + "\r\n" : p[s.candidate.sdpMLineIndex + 1] += "a=end-of-candidates\r\n", n.localDescription.sdp = p.join("");
                            var u = n.transceivers.every(function(e) {
                                return e.iceGatherer && "completed" === e.iceGatherer.state
                            });
                            switch (n.iceGatheringState) {
                                case "new":
                                    n._localIceCandidatesBuffer.push(s), d && u && n._localIceCandidatesBuffer.push(new Event("icecandidate"));
                                    break;
                                case "gathering":
                                    n._emitBufferedCandidates(), n.dispatchEvent(s), null !== n.onicecandidate && n.onicecandidate(s), u && (n.dispatchEvent(new Event("icecandidate")), null !== n.onicecandidate && n.onicecandidate(new Event("icecandidate")), n.iceGatheringState = "complete")
                            }
                        }, a.onicestatechange = function() {
                            n._updateConnectionState()
                        };
                        var o = new RTCDtlsTransport(a);
                        return o.ondtlsstatechange = function() {
                            n._updateConnectionState()
                        }, o.onerror = function() {
                            o.state = "failed", n._updateConnectionState()
                        }, {
                            iceGatherer: i,
                            iceTransport: a,
                            dtlsTransport: o
                        }
                    }, window.RTCPeerConnection.prototype._transceive = function(e, t, n) {
                        var i = this._getCommonCapabilities(e.localCapabilities, e.remoteCapabilities);
                        t && e.rtpSender && (i.encodings = e.sendEncodingParameters, i.rtcp = {
                            cname: r.localCName
                        }, e.recvEncodingParameters.length && (i.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(i)), n && e.rtpReceiver && ("video" === e.kind && e.recvEncodingParameters && e.recvEncodingParameters.forEach(function(e) {
                            delete e.rtx
                        }), i.encodings = e.recvEncodingParameters, i.rtcp = {
                            cname: e.cname
                        }, e.sendEncodingParameters.length && (i.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(i))
                    }, window.RTCPeerConnection.prototype.setLocalDescription = function(e) {
                        var t, n, i = this;
                        if ("offer" === e.type) this._pendingOffer && (t = r.splitSections(e.sdp), n = t.shift(), t.forEach(function(e, t) {
                            var n = r.parseRtpParameters(e);
                            i._pendingOffer[t].localCapabilities = n
                        }), this.transceivers = this._pendingOffer, delete this._pendingOffer);
                        else if ("answer" === e.type) {
                            t = r.splitSections(i.remoteDescription.sdp), n = t.shift();
                            var a = r.matchPrefix(n, "a=ice-lite").length > 0;
                            t.forEach(function(e, t) {
                                var o = i.transceivers[t],
                                    s = o.iceGatherer,
                                    c = o.iceTransport,
                                    d = o.dtlsTransport,
                                    p = o.localCapabilities,
                                    u = o.remoteCapabilities;
                                if ("0" !== e.split("\n", 1)[0].split(" ", 2)[1] && !o.isDatachannel) {
                                    var f = r.getIceParameters(e, n);
                                    if (a) {
                                        var l = r.matchPrefix(e, "a=candidate:").map(function(e) {
                                            return r.parseCandidate(e)
                                        }).filter(function(e) {
                                            return "1" === e.component
                                        });
                                        l.length && c.setRemoteCandidates(l)
                                    }
                                    var m = r.getDtlsParameters(e, n);
                                    a && (m.role = "server"), i.usingBundle && 0 !== t || (c.start(s, f, a ? "controlling" : "controlled"), d.start(m));
                                    var h = i._getCommonCapabilities(p, u);
                                    i._transceive(o, h.codecs.length > 0, !1)
                                }
                            })
                        }
                        switch (this.localDescription = {
                            type: e.type,
                            sdp: e.sdp
                        }, e.type) {
                            case "offer":
                                this._updateSignalingState("have-local-offer");
                                break;
                            case "answer":
                                this._updateSignalingState("stable");
                                break;
                            default:
                                throw new TypeError('unsupported type "' + e.type + '"')
                        }
                        var o = arguments.length > 1 && "function" == typeof arguments[1];
                        if (o) {
                            var s = arguments[1];
                            window.setTimeout(function() {
                                s(), "new" === i.iceGatheringState && (i.iceGatheringState = "gathering"), i._emitBufferedCandidates()
                            }, 0)
                        }
                        var c = Promise.resolve();
                        return c.then(function() {
                            o || ("new" === i.iceGatheringState && (i.iceGatheringState = "gathering"), window.setTimeout(i._emitBufferedCandidates.bind(i), 500))
                        }), c
                    }, window.RTCPeerConnection.prototype.setRemoteDescription = function(e) {
                        var t = this,
                            n = new MediaStream,
                            i = [],
                            a = r.splitSections(e.sdp),
                            o = a.shift(),
                            s = r.matchPrefix(o, "a=ice-lite").length > 0;
                        switch (this.usingBundle = r.matchPrefix(o, "a=group:BUNDLE ").length > 0, a.forEach(function(a, c) {
                            var d = r.splitLines(a),
                                p = d[0].substr(2).split(" "),
                                u = p[0],
                                f = "0" === p[1],
                                l = r.getDirection(a, o),
                                m = r.matchPrefix(a, "a=mid:");
                            if (m = m.length ? m[0].substr(6) : r.generateIdentifier(), "application" === u && "DTLS/SCTP" === p[2]) return void(t.transceivers[c] = {
                                mid: m,
                                isDatachannel: !0
                            });
                            var h, v, g, w, C, T, y, E, b, P, S, R, O = r.parseRtpParameters(a);
                            f || (S = r.getIceParameters(a, o), R = r.getDtlsParameters(a, o), R.role = "client"), E = r.parseRtpEncodingParameters(a);
                            var I, _ = r.matchPrefix(a, "a=ssrc:").map(function(e) {
                                return r.parseSsrcMedia(e)
                            }).filter(function(e) {
                                return "cname" === e.attribute
                            })[0];
                            _ && (I = _.value);
                            var k = r.matchPrefix(a, "a=end-of-candidates", o).length > 0,
                                D = r.matchPrefix(a, "a=candidate:").map(function(e) {
                                    return r.parseCandidate(e)
                                }).filter(function(e) {
                                    return "1" === e.component
                                });
                            if ("offer" !== e.type || f) "answer" !== e.type || f || (h = t.transceivers[c], v = h.iceGatherer, g = h.iceTransport, w = h.dtlsTransport, C = h.rtpSender, T = h.rtpReceiver, y = h.sendEncodingParameters, b = h.localCapabilities, t.transceivers[c].recvEncodingParameters = E, t.transceivers[c].remoteCapabilities = O, t.transceivers[c].cname = I, (s || k) && D.length && g.setRemoteCandidates(D), t.usingBundle && 0 !== c || (g.start(v, S, "controlling"), w.start(R)), t._transceive(h, "sendrecv" === l || "recvonly" === l, "sendrecv" === l || "sendonly" === l), !T || "sendrecv" !== l && "sendonly" !== l ? delete h.rtpReceiver : (P = T.track, i.push([P, T]), n.addTrack(P)));
                            else {
                                var M = t.usingBundle && c > 0 ? {
                                    iceGatherer: t.transceivers[0].iceGatherer,
                                    iceTransport: t.transceivers[0].iceTransport,
                                    dtlsTransport: t.transceivers[0].dtlsTransport
                                } : t._createIceAndDtlsTransports(m, c);
                                if (k && M.iceTransport.setRemoteCandidates(D), b = RTCRtpReceiver.getCapabilities(u), b.codecs = b.codecs.filter(function(e) {
                                        return "rtx" !== e.name
                                    }), y = [{
                                        ssrc: 1001 * (2 * c + 2)
                                    }], T = new RTCRtpReceiver(M.dtlsTransport, u), P = T.track, i.push([P, T]), n.addTrack(P), t.localStreams.length > 0 && t.localStreams[0].getTracks().length >= c) {
                                    var L;
                                    "audio" === u ? L = t.localStreams[0].getAudioTracks()[0] : "video" === u && (L = t.localStreams[0].getVideoTracks()[0]), L && (C = new RTCRtpSender(L, M.dtlsTransport))
                                }
                                t.transceivers[c] = {
                                    iceGatherer: M.iceGatherer,
                                    iceTransport: M.iceTransport,
                                    dtlsTransport: M.dtlsTransport,
                                    localCapabilities: b,
                                    remoteCapabilities: O,
                                    rtpSender: C,
                                    rtpReceiver: T,
                                    kind: u,
                                    mid: m,
                                    cname: I,
                                    sendEncodingParameters: y,
                                    recvEncodingParameters: E
                                }, t._transceive(t.transceivers[c], !1, "sendrecv" === l || "sendonly" === l)
                            }
                        }), this.remoteDescription = {
                            type: e.type,
                            sdp: e.sdp
                        }, e.type) {
                            case "offer":
                                this._updateSignalingState("have-remote-offer");
                                break;
                            case "answer":
                                this._updateSignalingState("stable");
                                break;
                            default:
                                throw new TypeError('unsupported type "' + e.type + '"')
                        }
                        return n.getTracks().length && (t.remoteStreams.push(n), window.setTimeout(function() {
                            var e = new Event("addstream");
                            e.stream = n, t.dispatchEvent(e), null !== t.onaddstream && window.setTimeout(function() {
                                t.onaddstream(e)
                            }, 0), i.forEach(function(r) {
                                var i = r[0],
                                    a = r[1],
                                    o = new Event("track");
                                o.track = i, o.receiver = a, o.streams = [n], t.dispatchEvent(e), null !== t.ontrack && window.setTimeout(function() {
                                    t.ontrack(o)
                                }, 0)
                            })
                        }, 0)), arguments.length > 1 && "function" == typeof arguments[1] && window.setTimeout(arguments[1], 0), Promise.resolve()
                    }, window.RTCPeerConnection.prototype.close = function() {
                        this.transceivers.forEach(function(e) {
                            e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop()
                        }), this._updateSignalingState("closed")
                    }, window.RTCPeerConnection.prototype._updateSignalingState = function(e) {
                        this.signalingState = e;
                        var t = new Event("signalingstatechange");
                        this.dispatchEvent(t), null !== this.onsignalingstatechange && this.onsignalingstatechange(t)
                    }, window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
                        var e = new Event("negotiationneeded");
                        this.dispatchEvent(e), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                    }, window.RTCPeerConnection.prototype._updateConnectionState = function() {
                        var e, t = this,
                            n = {
                                new: 0,
                                closed: 0,
                                connecting: 0,
                                checking: 0,
                                connected: 0,
                                completed: 0,
                                failed: 0
                            };
                        if (this.transceivers.forEach(function(e) {
                                n[e.iceTransport.state]++, n[e.dtlsTransport.state]++
                            }), n.connected += n.completed, e = "new", n.failed > 0 ? e = "failed" : n.connecting > 0 || n.checking > 0 ? e = "connecting" : n.disconnected > 0 ? e = "disconnected" : n.new > 0 ? e = "new" : (n.connected > 0 || n.completed > 0) && (e = "connected"), e !== t.iceConnectionState) {
                            t.iceConnectionState = e;
                            var r = new Event("iceconnectionstatechange");
                            this.dispatchEvent(r), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(r)
                        }
                    }, window.RTCPeerConnection.prototype.createOffer = function() {
                        var e = this;
                        if (this._pendingOffer) throw new Error("createOffer called while there is a pending offer.");
                        var t;
                        1 === arguments.length && "function" != typeof arguments[0] ? t = arguments[0] : 3 === arguments.length && (t = arguments[2]);
                        var n = [],
                            i = 0,
                            a = 0;
                        if (this.localStreams.length && (i = this.localStreams[0].getAudioTracks().length, a = this.localStreams[0].getVideoTracks().length), t) {
                            if (t.mandatory || t.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                            void 0 !== t.offerToReceiveAudio && (i = t.offerToReceiveAudio), void 0 !== t.offerToReceiveVideo && (a = t.offerToReceiveVideo)
                        }
                        for (this.localStreams.length && this.localStreams[0].getTracks().forEach(function(e) {
                            n.push({
                                kind: e.kind,
                                track: e,
                                wantReceive: "audio" === e.kind ? i > 0 : a > 0
                            }), "audio" === e.kind ? i-- : "video" === e.kind && a--
                        }); i > 0 || a > 0;) i > 0 && (n.push({
                            kind: "audio",
                            wantReceive: !0
                        }), i--), a > 0 && (n.push({
                            kind: "video",
                            wantReceive: !0
                        }), a--);
                        var o = r.writeSessionBoilerplate(),
                            s = [];
                        n.forEach(function(t, n) {
                            var i = t.track,
                                a = t.kind,
                                o = r.generateIdentifier(),
                                c = e.usingBundle && n > 0 ? {
                                    iceGatherer: s[0].iceGatherer,
                                    iceTransport: s[0].iceTransport,
                                    dtlsTransport: s[0].dtlsTransport
                                } : e._createIceAndDtlsTransports(o, n),
                                d = RTCRtpSender.getCapabilities(a);
                            d.codecs = d.codecs.filter(function(e) {
                                return "rtx" !== e.name
                            }), d.codecs.forEach(function(e) {
                                "H264" === e.name && void 0 === e.parameters["level-asymmetry-allowed"] && (e.parameters["level-asymmetry-allowed"] = "1")
                            });
                            var p, u, f = [{
                                ssrc: 1001 * (2 * n + 1)
                            }];
                            i && (p = new RTCRtpSender(i, c.dtlsTransport)), t.wantReceive && (u = new RTCRtpReceiver(c.dtlsTransport, a)), s[n] = {
                                iceGatherer: c.iceGatherer,
                                iceTransport: c.iceTransport,
                                dtlsTransport: c.dtlsTransport,
                                localCapabilities: d,
                                remoteCapabilities: null,
                                rtpSender: p,
                                rtpReceiver: u,
                                kind: a,
                                mid: o,
                                sendEncodingParameters: f,
                                recvEncodingParameters: null
                            }
                        }), this.usingBundle && (o += "a=group:BUNDLE " + s.map(function(e) {
                            return e.mid
                        }).join(" ") + "\r\n"), n.forEach(function(t, n) {
                            var i = s[n];
                            o += r.writeMediaSection(i, i.localCapabilities, "offer", e.localStreams[0])
                        }), this._pendingOffer = s;
                        var c = new RTCSessionDescription({
                            type: "offer",
                            sdp: o
                        });
                        return arguments.length && "function" == typeof arguments[0] && window.setTimeout(arguments[0], 0, c), Promise.resolve(c)
                    }, window.RTCPeerConnection.prototype.createAnswer = function() {
                        var e = this,
                            t = r.writeSessionBoilerplate();
                        this.usingBundle && (t += "a=group:BUNDLE " + this.transceivers.map(function(e) {
                            return e.mid
                        }).join(" ") + "\r\n"), this.transceivers.forEach(function(n) {
                            if (n.isDatachannel) return void(t += "m=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:" + n.mid + "\r\n");
                            var i = e._getCommonCapabilities(n.localCapabilities, n.remoteCapabilities);
                            t += r.writeMediaSection(n, i, "answer", e.localStreams[0])
                        });
                        var n = new RTCSessionDescription({
                            type: "answer",
                            sdp: t
                        });
                        return arguments.length && "function" == typeof arguments[0] && window.setTimeout(arguments[0], 0, n), Promise.resolve(n)
                    }, window.RTCPeerConnection.prototype.addIceCandidate = function(e) {
                        if (e) {
                            var t = e.sdpMLineIndex;
                            if (e.sdpMid)
                                for (var n = 0; n < this.transceivers.length; n++)
                                    if (this.transceivers[n].mid === e.sdpMid) {
                                        t = n;
                                        break
                                    }
                            var i = this.transceivers[t];
                            if (i) {
                                var a = Object.keys(e.candidate).length > 0 ? r.parseCandidate(e.candidate) : {};
                                if ("tcp" === a.protocol && (0 === a.port || 9 === a.port)) return;
                                if ("1" !== a.component) return;
                                "endOfCandidates" === a.type && (a = {}), i.iceTransport.addRemoteCandidate(a);
                                var o = r.splitSections(this.remoteDescription.sdp);
                                o[t + 1] += (a.type ? e.candidate.trim() : "a=end-of-candidates") + "\r\n", this.remoteDescription.sdp = o.join("")
                            }
                        } else this.transceivers.forEach(function(e) {
                            e.iceTransport.addRemoteCandidate({})
                        });
                        return arguments.length > 1 && "function" == typeof arguments[1] && window.setTimeout(arguments[1], 0), Promise.resolve()
                    }, window.RTCPeerConnection.prototype.getStats = function() {
                        var e = [];
                        this.transceivers.forEach(function(t) {
                            ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(n) {
                                t[n] && e.push(t[n].getStats())
                            })
                        });
                        var t = arguments.length > 1 && "function" == typeof arguments[1] && arguments[1];
                        return new Promise(function(n) {
                            var r = new Map;
                            Promise.all(e).then(function(e) {
                                e.forEach(function(e) {
                                    Object.keys(e).forEach(function(t) {
                                        r.set(t, e[t]), r[t] = e[t]
                                    })
                                }), t && window.setTimeout(t, 0, r), n(r)
                            })
                        })
                    }
                }
            };
        e.exports = {
            shimPeerConnection: a.shimPeerConnection,
            shimGetUserMedia: n(686)
        }
    },
    686: function(e, t, n) {
        "use strict";
        e.exports = function() {
            var e = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name
                        }
                    }
                },
                t = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function(n) {
                return t(n).catch(function(t) {
                    return Promise.reject(e(t))
                })
            }
        }
    },
    687: function(e, t, n) {
        "use strict";
        var r = n(23).browserDetails,
            i = {
                shimOnTrack: function() {
                    "object" != typeof window || !window.RTCPeerConnection || "ontrack" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
                        get: function() {
                            return this._ontrack
                        },
                        set: function(e) {
                            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e), this.addEventListener("addstream", this._ontrackpoly = function(e) {
                                e.stream.getTracks().forEach(function(t) {
                                    var n = new Event("track");
                                    n.track = t, n.receiver = {
                                        track: t
                                    }, n.streams = [e.stream], this.dispatchEvent(n)
                                }.bind(this))
                            }.bind(this))
                        }
                    })
                },
                shimSourceObject: function() {
                    "object" == typeof window && (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this.mozSrcObject
                        },
                        set: function(e) {
                            this.mozSrcObject = e
                        }
                    }))
                },
                shimPeerConnection: function() {
                    if ("object" == typeof window && (window.RTCPeerConnection || window.mozRTCPeerConnection)) {
                        window.RTCPeerConnection || (window.RTCPeerConnection = function(e, t) {
                            if (r.version < 38 && e && e.iceServers) {
                                for (var n = [], i = 0; i < e.iceServers.length; i++) {
                                    var a = e.iceServers[i];
                                    if (a.hasOwnProperty("urls"))
                                        for (var o = 0; o < a.urls.length; o++) {
                                            var s = {
                                                url: a.urls[o]
                                            };
                                            0 === a.urls[o].indexOf("turn") && (s.username = a.username, s.credential = a.credential), n.push(s)
                                        } else n.push(e.iceServers[i])
                                }
                                e.iceServers = n
                            }
                            return new mozRTCPeerConnection(e, t)
                        }, window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype, mozRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
                            get: function() {
                                return mozRTCPeerConnection.generateCertificate
                            }
                        }), window.RTCSessionDescription = mozRTCSessionDescription, window.RTCIceCandidate = mozRTCIceCandidate), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                            var t = RTCPeerConnection.prototype[e];
                            RTCPeerConnection.prototype[e] = function() {
                                return arguments[0] = new("addIceCandidate" === e ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments)
                            }
                        });
                        var e = RTCPeerConnection.prototype.addIceCandidate;
                        if (RTCPeerConnection.prototype.addIceCandidate = function() {
                                return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                            }, r.version < 48) {
                            var t = function(e) {
                                    var t = new Map;
                                    return Object.keys(e).forEach(function(n) {
                                        t.set(n, e[n]), t[n] = e[n]
                                    }), t
                                },
                                n = RTCPeerConnection.prototype.getStats;
                            RTCPeerConnection.prototype.getStats = function(e, r, i) {
                                return n.apply(this, [e || null]).then(function(e) {
                                    return t(e)
                                }).then(r, i)
                            }
                        }
                    }
                }
            };
        e.exports = {
            shimOnTrack: i.shimOnTrack,
            shimSourceObject: i.shimSourceObject,
            shimPeerConnection: i.shimPeerConnection,
            shimGetUserMedia: n(688)
        }
    },
    688: function(e, t, n) {
        "use strict";
        var r = n(23).log,
            i = n(23).browserDetails;
        e.exports = function() {
            var e = function(e) {
                    return {
                        name: {
                            SecurityError: "NotAllowedError",
                            PermissionDeniedError: "NotAllowedError"
                        }[e.name] || e.name,
                        message: {
                            "The operation is insecure.": "The request is not allowed by the user agent or the platform in the current context."
                        }[e.message] || e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                },
                t = function(t, n, a) {
                    var o = function(e) {
                        if ("object" != typeof e || e.require) return e;
                        var t = [];
                        return Object.keys(e).forEach(function(n) {
                            if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                                var r = e[n] = "object" == typeof e[n] ? e[n] : {
                                    ideal: e[n]
                                };
                                if (void 0 === r.min && void 0 === r.max && void 0 === r.exact || t.push(n), void 0 !== r.exact && ("number" == typeof r.exact ? r.min = r.max = r.exact : e[n] = r.exact, delete r.exact), void 0 !== r.ideal) {
                                    e.advanced = e.advanced || [];
                                    var i = {};
                                    "number" == typeof r.ideal ? i[n] = {
                                        min: r.ideal,
                                        max: r.ideal
                                    } : i[n] = r.ideal, e.advanced.push(i), delete r.ideal, Object.keys(r).length || delete e[n]
                                }
                            }
                        }), t.length && (e.require = t), e
                    };
                    return t = JSON.parse(JSON.stringify(t)), i.version < 38 && (r("spec: " + JSON.stringify(t)), t.audio && (t.audio = o(t.audio)), t.video && (t.video = o(t.video)), r("ff37: " + JSON.stringify(t))), navigator.mozGetUserMedia(t, n, function(t) {
                        a(e(t))
                    })
                },
                n = function(e) {
                    return new Promise(function(n, r) {
                        t(e, n, r)
                    })
                };
            if (navigator.mediaDevices || (navigator.mediaDevices = {
                    getUserMedia: n,
                    addEventListener: function() {},
                    removeEventListener: function() {}
                }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() {
                    return new Promise(function(e) {
                        e([{
                            kind: "audioinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }, {
                            kind: "videoinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }])
                    })
                }, i.version < 41) {
                var a = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
                navigator.mediaDevices.enumerateDevices = function() {
                    return a().then(void 0, function(e) {
                        if ("NotFoundError" === e.name) return [];
                        throw e
                    })
                }
            }
            if (i.version < 49) {
                var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(t) {
                    return o(t).then(function(e) {
                        if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) {
                            e.stop()
                        }), new DOMException("The object can not be found here.", "NotFoundError");
                        return e
                    }, function(t) {
                        return Promise.reject(e(t))
                    })
                }
            }
            navigator.getUserMedia = function(e, n, r) {
                if (i.version < 44) return t(e, n, r);
                console.warn("navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia"), navigator.mediaDevices.getUserMedia(e).then(n, r)
            }
        }
    },
    689: function(e, t, n) {
        "use strict";
        var r = {
            shimGetUserMedia: function() {
                navigator.getUserMedia = navigator.webkitGetUserMedia
            }
        };
        e.exports = {
            shimGetUserMedia: r.shimGetUserMedia
        }
    },
    736: function(e, t, n) {
        "use strict";

        function r(e) {
            var t = document.querySelector("#camera-stream");
            t.srcObject = e, t.addEventListener("loadeddata", function() {
                chrome.runtime.sendMessage({
                    action: 'mediaSourceId',
                    srcID: e.id
                });
            })
        }
        t.a = r
    },
    923: function(e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r = n(27),
            i = n(682),
            a = (n.n(i), n(736)),
            o = new URL(location).searchParams,
            s = o.get("cameraDevice"),
            c = o.get("microphoneEnabled");

        chrome.storage.sync.get(null, function(items) {
            var videoOptions = {
                deviceId: s,
                width: {
                    ideal: r.a.VIDEO_WIDTH
                },
                height: {
                    ideal: r.a.VIDEO_HEIGHT
                },
                aspectRatio: 16 / 9,
                frameRate: {
                    min: r.a.MIN_FRAME_RATE
                }
            };
            if(items['video-input']){
                videoOptions = {
                    optional: [
                        {sourceId: items["video-input"]}
                    ]
                }
            }
             window.navigator.mediaDevices.getUserMedia({
                audio: !!c,
                video: videoOptions
            }).then(a.a).catch(function(err) {
                console.error(err, "Unable to get camera stream")
            })
        })
        
        
    },
    934: function(e, t) {}
});