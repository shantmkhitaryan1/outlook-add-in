! function(e) {
    function t(r) {
        if (n[r]) return n[r].exports;
        var i = n[r] = {
            exports: {},
            id: r,
            loaded: !1
        };
        return e[r].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports
    }
    var n = {};
    return t.m = e, t.c = n, t.p = "", t(0)
}({
    0: function(e, t, n) {
        n(664), e.exports = n(665)
    },
    352: function(e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var n = {
            POPUP_PATH: "popup.html",
            DEFAULT_TAG_ON_PLAYER_CREATION: "Created by ViewedIt",
            Tabs: {
                FEED: "feed",
                LIBRARY: "library"
            },
            RELOAD_DELAY_IN_MS: 3e3,
            COUNTDOWN_LENGTH_IN_MS: 3e3,
            WELCOME_PAGE_DELAY_MS: 3e3,
            START_RECORDING_DELAY_MS: 250,
            TIMER_VISIBILITY_DELAY_IN_MS: 250,
            Sources: {
                TAB: "tab",
                SCREEN: "screen",
                CAMERA: "camera"
            },
            Bitrate: {
                TWO_KBPS: 2e6,
                ONE_KBPS: 1e6
            },
            MIN_FRAME_RATE: 25,
            VIDEO_HEIGHT: 720,
            VIDEO_WIDTH: 1280,
            MAX_BUFFER_DURATION_MS: 500,
            MAX_EMPTY_BLOBS: 5,
            MAX_CONNECTION_FAILURES: 3,
            CONNECTION_CHECK_POLL_MILLISECONDS: 5e3,
            Analytics: {
                Sources: {
                    TIMER_STOP: "timer-stop",
                    COUNTDOWN_ABORT: "countdown-abort",
                    CAMERA_ONLY_CANCEL: "camera-only-cancel"
                }
            }
        };
        t.default = n
    },
    373: function(e, t, n) {
        "use strict";
        ! function() {
            var t = n(374).log,
                r = n(374).browserDetails;
            e.exports.browserDetails = r, e.exports.extractVersion = n(374).extractVersion, e.exports.disableLog = n(374).disableLog;
            var i = n(375) || null,
                a = n(377) || null,
                o = n(380) || null,
                s = n(382) || null;
            switch (r.browser) {
                case "opera":
                case "chrome":
                    if (!i || !i.shimPeerConnection) return void t("Chrome shim is not included in this adapter release.");
                    t("adapter.js shimming chrome."), e.exports.browserShim = i, i.shimGetUserMedia(), i.shimMediaStream(), i.shimSourceObject(), i.shimPeerConnection(), i.shimOnTrack();
                    break;
                case "firefox":
                    if (!o || !o.shimPeerConnection) return void t("Firefox shim is not included in this adapter release.");
                    t("adapter.js shimming firefox."), e.exports.browserShim = o, o.shimGetUserMedia(), o.shimSourceObject(), o.shimPeerConnection(), o.shimOnTrack();
                    break;
                case "edge":
                    if (!a || !a.shimPeerConnection) return void t("MS edge shim is not included in this adapter release.");
                    t("adapter.js shimming edge."), e.exports.browserShim = a, a.shimGetUserMedia(), a.shimPeerConnection();
                    break;
                case "safari":
                    if (!s) return void t("Safari shim is not included in this adapter release.");
                    t("adapter.js shimming safari."), e.exports.browserShim = s, s.shimGetUserMedia();
                    break;
                default:
                    t("Unsupported browser!")
            }
        }()
    },
    374: function(e, t) {
        "use strict";
        var n = !0,
            r = {
                disableLog: function(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (n = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                },
                log: function() {
                    if ("object" == typeof window) {
                        if (n) return;
                        "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                    }
                },
                extractVersion: function(e, t, n) {
                    var r = e.match(t);
                    return r && r.length >= n && parseInt(r[n], 10)
                },
                detectBrowser: function() {
                    var e = {};
                    if (e.browser = null, e.version = null, "undefined" == typeof window || !window.navigator) return e.browser = "Not a browser.", e;
                    if (navigator.mozGetUserMedia) e.browser = "firefox", e.version = this.extractVersion(navigator.userAgent, /Firefox\/([0-9]+)\./, 1);
                    else if (navigator.webkitGetUserMedia)
                        if (window.webkitRTCPeerConnection) e.browser = "chrome", e.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\/([0-9]+)\./, 2);
                        else {
                            if (!navigator.userAgent.match(/Version\/(\d+).(\d+)/)) return e.browser = "Unsupported webkit-based browser with GUM support but no WebRTC support.", e;
                            e.browser = "safari", e.version = this.extractVersion(navigator.userAgent, /AppleWebKit\/([0-9]+)\./, 1)
                        }
                    else {
                        if (!navigator.mediaDevices || !navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) return e.browser = "Not a supported browser.", e;
                        e.browser = "edge", e.version = this.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2)
                    }
                    return e
                }
            };
        e.exports = {
            log: r.log,
            disableLog: r.disableLog,
            browserDetails: r.detectBrowser(),
            extractVersion: r.extractVersion
        }
    },
    375: function(e, t, n) {
        "use strict";
        var r = n(374).log,
            i = n(374).browserDetails,
            a = {
                shimMediaStream: function() {
                    window.MediaStream = window.MediaStream || window.webkitMediaStream
                },
                shimOnTrack: function() {
                    "object" != typeof window || !window.RTCPeerConnection || "ontrack" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
                        get: function() {
                            return this._ontrack
                        },
                        set: function(e) {
                            var t = this;
                            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e), this.addEventListener("addstream", this._ontrackpoly = function(e) {
                                e.stream.addEventListener("addtrack", function(n) {
                                    var r = new Event("track");
                                    r.track = n.track, r.receiver = {
                                        track: n.track
                                    }, r.streams = [e.stream], t.dispatchEvent(r)
                                }), e.stream.getTracks().forEach(function(t) {
                                    var n = new Event("track");
                                    n.track = t, n.receiver = {
                                        track: t
                                    }, n.streams = [e.stream], this.dispatchEvent(n)
                                }.bind(this))
                            }.bind(this))
                        }
                    })
                },
                shimSourceObject: function() {
                    "object" == typeof window && (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this._srcObject
                        },
                        set: function(e) {
                            var t = this;
                            return this._srcObject = e, this.src && URL.revokeObjectURL(this.src), e ? (this.srcObject = e, e.addEventListener("addtrack", function() {
                                t.src && URL.revokeObjectURL(t.src), t.srcObject = e
                            }), void e.addEventListener("removetrack", function() {
                                t.src && URL.revokeObjectURL(t.src), t.srcObject = e
                            })) : void(this.src = "")
                        }
                    }))
                },
                shimPeerConnection: function() {
                    window.RTCPeerConnection = function(e, t) {
                        r("PeerConnection"), e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy);
                        var n = new webkitRTCPeerConnection(e, t),
                            i = n.getStats.bind(n);
                        return n.getStats = function(e, t, n) {
                            var r = this,
                                a = arguments;
                            if (arguments.length > 0 && "function" == typeof e) return i(e, t);
                            var o = function(e) {
                                    var t = {},
                                        n = e.result();
                                    return n.forEach(function(e) {
                                        var n = {
                                            id: e.id,
                                            timestamp: e.timestamp,
                                            type: e.type
                                        };
                                        e.names().forEach(function(t) {
                                            n[t] = e.stat(t)
                                        }), t[n.id] = n
                                    }), t
                                },
                                s = function(e, t) {
                                    var n = new Map(Object.keys(e).map(function(t) {
                                        return [t, e[t]]
                                    }));
                                    return t = t || e, Object.keys(t).forEach(function(e) {
                                        n[e] = t[e]
                                    }), n
                                };
                            if (arguments.length >= 2) {
                                var c = function(e) {
                                    a[1](s(o(e)))
                                };
                                return i.apply(this, [c, arguments[0]])
                            }
                            return new Promise(function(t, n) {
                                1 === a.length && "object" == typeof e ? i.apply(r, [function(e) {
                                    t(s(o(e)))
                                }, n]) : i.apply(r, [function(e) {
                                    t(s(o(e), e.result()))
                                }, n])
                            }).then(t, n)
                        }, n
                    }, window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype, webkitRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
                        get: function() {
                            return webkitRTCPeerConnection.generateCertificate
                        }
                    }), ["createOffer", "createAnswer"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            var e = this;
                            if (arguments.length < 1 || 1 === arguments.length && "object" == typeof arguments[0]) {
                                var n = 1 === arguments.length ? arguments[0] : void 0;
                                return new Promise(function(r, i) {
                                    t.apply(e, [r, i, n])
                                })
                            }
                            return t.apply(this, arguments)
                        }
                    }), i.version < 51 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            var e = arguments,
                                n = this,
                                r = new Promise(function(r, i) {
                                    t.apply(n, [e[0], r, i])
                                });
                            return e.length < 2 ? r : r.then(function() {
                                e[1].apply(null, [])
                            }, function(t) {
                                e.length >= 3 && e[2].apply(null, [t])
                            })
                        }
                    }), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                        var t = webkitRTCPeerConnection.prototype[e];
                        webkitRTCPeerConnection.prototype[e] = function() {
                            return arguments[0] = new("addIceCandidate" === e ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments)
                        }
                    });
                    var e = RTCPeerConnection.prototype.addIceCandidate;
                    RTCPeerConnection.prototype.addIceCandidate = function() {
                        return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                    }
                }
            };
        e.exports = {
            shimMediaStream: a.shimMediaStream,
            shimOnTrack: a.shimOnTrack,
            shimSourceObject: a.shimSourceObject,
            shimPeerConnection: a.shimPeerConnection,
            shimGetUserMedia: n(376)
        }
    },
    376: function(e, t, n) {
        "use strict";
        var r = n(374).log;
        e.exports = function() {
            var e = function(e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    var t = {};
                    return Object.keys(e).forEach(function(n) {
                        if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                            var r = "object" == typeof e[n] ? e[n] : {
                                ideal: e[n]
                            };
                            void 0 !== r.exact && "number" == typeof r.exact && (r.min = r.max = r.exact);
                            var i = function(e, t) {
                                return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                            };
                            if (void 0 !== r.ideal) {
                                t.optional = t.optional || [];
                                var a = {};
                                "number" == typeof r.ideal ? (a[i("min", n)] = r.ideal, t.optional.push(a), a = {}, a[i("max", n)] = r.ideal, t.optional.push(a)) : (a[i("", n)] = r.ideal, t.optional.push(a))
                            }
                            void 0 !== r.exact && "number" != typeof r.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[i("", n)] = r.exact) : ["min", "max"].forEach(function(e) {
                                void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, n)] = r[e])
                            })
                        }
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                t = function(t, n) {
                    if (t = JSON.parse(JSON.stringify(t)), t && t.audio && (t.audio = e(t.audio)), t && "object" == typeof t.video) {
                        var i = t.video.facingMode;
                        if (i = i && ("object" == typeof i ? i : {
                                ideal: i
                            }), i && ("user" === i.exact || "environment" === i.exact || "user" === i.ideal || "environment" === i.ideal) && (!navigator.mediaDevices.getSupportedConstraints || !navigator.mediaDevices.getSupportedConstraints().facingMode) && (delete t.video.facingMode, "environment" === i.exact || "environment" === i.ideal)) return navigator.mediaDevices.enumerateDevices().then(function(a) {
                            a = a.filter(function(e) {
                                return "videoinput" === e.kind
                            });
                            var o = a.find(function(e) {
                                return e.label.toLowerCase().indexOf("back") !== -1
                            }) || a.length && a[a.length - 1];
                            return o && (t.video.deviceId = i.exact ? {
                                exact: o.deviceId
                            } : {
                                ideal: o.deviceId
                            }), t.video = e(t.video), r("chrome: " + JSON.stringify(t)), n(t)
                        });
                        t.video = e(t.video)
                    }
                    return r("chrome: " + JSON.stringify(t)), n(t)
                },
                n = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            ConstraintNotSatisfiedError: "OverconstrainedError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraintName,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                },
                i = function(e, r, i) {
                    t(e, function(e) {
                        navigator.webkitGetUserMedia(e, r, function(e) {
                            i(n(e))
                        })
                    })
                };
            navigator.getUserMedia = i;
            var a = function(e) {
                return new Promise(function(t, n) {
                    navigator.getUserMedia(e, t, n)
                })
            };
            if (navigator.mediaDevices || (navigator.mediaDevices = {
                    getUserMedia: a,
                    enumerateDevices: function() {
                        return new Promise(function(e) {
                            var t = {
                                audio: "audioinput",
                                video: "videoinput"
                            };
                            return MediaStreamTrack.getSources(function(n) {
                                e(n.map(function(e) {
                                    return {
                                        label: e.label,
                                        kind: t[e.kind],
                                        deviceId: e.id,
                                        groupId: ""
                                    }
                                }))
                            })
                        })
                    }
                }), navigator.mediaDevices.getUserMedia) {
                var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(e) {
                    return t(e, function(e) {
                        return o(e).then(function(t) {
                            if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(function(e) {
                                e.stop()
                            }), new DOMException("", "NotFoundError");
                            return t
                        }, function(e) {
                            return Promise.reject(n(e))
                        })
                    })
                }
            } else navigator.mediaDevices.getUserMedia = function(e) {
                return a(e)
            };
            "undefined" == typeof navigator.mediaDevices.addEventListener && (navigator.mediaDevices.addEventListener = function() {
                r("Dummy mediaDevices.addEventListener called.")
            }), "undefined" == typeof navigator.mediaDevices.removeEventListener && (navigator.mediaDevices.removeEventListener = function() {
                r("Dummy mediaDevices.removeEventListener called.")
            })
        }
    },
    377: function(e, t, n) {
        "use strict";
        var r = n(378),
            i = n(374).browserDetails,
            a = {
                shimPeerConnection: function() {
                    if (window.RTCIceGatherer) {
                        window.RTCIceCandidate || (window.RTCIceCandidate = function(e) {
                            return e
                        }), window.RTCSessionDescription || (window.RTCSessionDescription = function(e) {
                            return e
                        });
                        var e = Object.getOwnPropertyDescriptor(MediaStreamTrack.prototype, "enabled");
                        Object.defineProperty(MediaStreamTrack.prototype, "enabled", {
                            set: function(t) {
                                e.set.call(this, t);
                                var n = new Event("enabled");
                                n.enabled = t, this.dispatchEvent(n)
                            }
                        })
                    }
                    window.RTCPeerConnection = function(e) {
                        var t = this,
                            n = document.createDocumentFragment();
                        if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(e) {
                                t[e] = n[e].bind(n)
                            }), this.onicecandidate = null, this.onaddstream = null, this.ontrack = null, this.onremovestream = null, this.onsignalingstatechange = null, this.oniceconnectionstatechange = null, this.onnegotiationneeded = null, this.ondatachannel = null, this.localStreams = [], this.remoteStreams = [], this.getLocalStreams = function() {
                                return t.localStreams
                            }, this.getRemoteStreams = function() {
                                return t.remoteStreams
                            }, this.localDescription = new RTCSessionDescription({
                                type: "",
                                sdp: ""
                            }), this.remoteDescription = new RTCSessionDescription({
                                type: "",
                                sdp: ""
                            }), this.signalingState = "stable", this.iceConnectionState = "new", this.iceGatheringState = "new", this.iceOptions = {
                                gatherPolicy: "all",
                                iceServers: []
                            }, e && e.iceTransportPolicy) switch (e.iceTransportPolicy) {
                            case "all":
                            case "relay":
                                this.iceOptions.gatherPolicy = e.iceTransportPolicy;
                                break;
                            case "none":
                                throw new TypeError('iceTransportPolicy "none" not supported')
                        }
                        if (this.usingBundle = e && "max-bundle" === e.bundlePolicy, e && e.iceServers) {
                            var r = JSON.parse(JSON.stringify(e.iceServers));
                            this.iceOptions.iceServers = r.filter(function(e) {
                                if (e && e.urls) {
                                    var t = e.urls;
                                    return "string" == typeof t && (t = [t]), t = t.filter(function(e) {
                                        return 0 === e.indexOf("turn:") && e.indexOf("transport=udp") !== -1 && e.indexOf("turn:[") === -1 || 0 === e.indexOf("stun:") && i.version >= 14393
                                    })[0], !!t
                                }
                                return !1
                            })
                        }
                        this._config = e, this.transceivers = [], this._localIceCandidatesBuffer = []
                    }, window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
                        var e = this,
                            t = r.splitSections(e.localDescription.sdp);
                        this._localIceCandidatesBuffer.forEach(function(n) {
                            var r = !n.candidate || 0 === Object.keys(n.candidate).length;
                            if (r)
                                for (var i = 1; i < t.length; i++) t[i].indexOf("\r\na=end-of-candidates\r\n") === -1 && (t[i] += "a=end-of-candidates\r\n");
                            else n.candidate.candidate.indexOf("typ endOfCandidates") === -1 && (t[n.candidate.sdpMLineIndex + 1] += "a=" + n.candidate.candidate + "\r\n");
                            if (e.localDescription.sdp = t.join(""), e.dispatchEvent(n), null !== e.onicecandidate && e.onicecandidate(n), !n.candidate && "complete" !== e.iceGatheringState) {
                                var a = e.transceivers.every(function(e) {
                                    return e.iceGatherer && "completed" === e.iceGatherer.state
                                });
                                a && (e.iceGatheringState = "complete")
                            }
                        }), this._localIceCandidatesBuffer = []
                    }, window.RTCPeerConnection.prototype.getConfiguration = function() {
                        return this._config
                    }, window.RTCPeerConnection.prototype.addStream = function(e) {
                        var t = e.clone();
                        e.getTracks().forEach(function(e, n) {
                            var r = t.getTracks()[n];
                            e.addEventListener("enabled", function(e) {
                                r.enabled = e.enabled
                            })
                        }), this.localStreams.push(t), this._maybeFireNegotiationNeeded()
                    }, window.RTCPeerConnection.prototype.removeStream = function(e) {
                        var t = this.localStreams.indexOf(e);
                        t > -1 && (this.localStreams.splice(t, 1), this._maybeFireNegotiationNeeded())
                    }, window.RTCPeerConnection.prototype.getSenders = function() {
                        return this.transceivers.filter(function(e) {
                            return !!e.rtpSender
                        }).map(function(e) {
                            return e.rtpSender
                        })
                    }, window.RTCPeerConnection.prototype.getReceivers = function() {
                        return this.transceivers.filter(function(e) {
                            return !!e.rtpReceiver
                        }).map(function(e) {
                            return e.rtpReceiver
                        })
                    }, window.RTCPeerConnection.prototype._getCommonCapabilities = function(e, t) {
                        var n = {
                            codecs: [],
                            headerExtensions: [],
                            fecMechanisms: []
                        };
                        return e.codecs.forEach(function(e) {
                            for (var r = 0; r < t.codecs.length; r++) {
                                var i = t.codecs[r];
                                if (e.name.toLowerCase() === i.name.toLowerCase() && e.clockRate === i.clockRate) {
                                    i.numChannels = Math.min(e.numChannels, i.numChannels), n.codecs.push(i), i.rtcpFeedback = i.rtcpFeedback.filter(function(t) {
                                        for (var n = 0; n < e.rtcpFeedback.length; n++)
                                            if (e.rtcpFeedback[n].type === t.type && e.rtcpFeedback[n].parameter === t.parameter) return !0;
                                        return !1
                                    });
                                    break
                                }
                            }
                        }), e.headerExtensions.forEach(function(e) {
                            for (var r = 0; r < t.headerExtensions.length; r++) {
                                var i = t.headerExtensions[r];
                                if (e.uri === i.uri) {
                                    n.headerExtensions.push(i);
                                    break
                                }
                            }
                        }), n
                    }, window.RTCPeerConnection.prototype._createIceAndDtlsTransports = function(e, t) {
                        var n = this,
                            i = new RTCIceGatherer(n.iceOptions),
                            a = new RTCIceTransport(i);
                        i.onlocalcandidate = function(o) {
                            var s = new Event("icecandidate");
                            s.candidate = {
                                sdpMid: e,
                                sdpMLineIndex: t
                            };
                            var c = o.candidate,
                                d = !c || 0 === Object.keys(c).length;
                            d ? (void 0 === i.state && (i.state = "completed"), s.candidate.candidate = "candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates") : (c.component = "RTCP" === a.component ? 2 : 1, s.candidate.candidate = r.writeCandidate(c));
                            var p = r.splitSections(n.localDescription.sdp);
                            s.candidate.candidate.indexOf("typ endOfCandidates") === -1 ? p[s.candidate.sdpMLineIndex + 1] += "a=" + s.candidate.candidate + "\r\n" : p[s.candidate.sdpMLineIndex + 1] += "a=end-of-candidates\r\n", n.localDescription.sdp = p.join("");
                            var u = n.transceivers.every(function(e) {
                                return e.iceGatherer && "completed" === e.iceGatherer.state
                            });
                            switch (n.iceGatheringState) {
                                case "new":
                                    n._localIceCandidatesBuffer.push(s), d && u && n._localIceCandidatesBuffer.push(new Event("icecandidate"));
                                    break;
                                case "gathering":
                                    n._emitBufferedCandidates(), n.dispatchEvent(s), null !== n.onicecandidate && n.onicecandidate(s), u && (n.dispatchEvent(new Event("icecandidate")), null !== n.onicecandidate && n.onicecandidate(new Event("icecandidate")), n.iceGatheringState = "complete");
                                    break;
                                case "complete":
                            }
                        }, a.onicestatechange = function() {
                            n._updateConnectionState()
                        };
                        var o = new RTCDtlsTransport(a);
                        return o.ondtlsstatechange = function() {
                            n._updateConnectionState()
                        }, o.onerror = function() {
                            o.state = "failed", n._updateConnectionState()
                        }, {
                            iceGatherer: i,
                            iceTransport: a,
                            dtlsTransport: o
                        }
                    }, window.RTCPeerConnection.prototype._transceive = function(e, t, n) {
                        var i = this._getCommonCapabilities(e.localCapabilities, e.remoteCapabilities);
                        t && e.rtpSender && (i.encodings = e.sendEncodingParameters, i.rtcp = {
                            cname: r.localCName
                        }, e.recvEncodingParameters.length && (i.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(i)), n && e.rtpReceiver && ("video" === e.kind && e.recvEncodingParameters && e.recvEncodingParameters.forEach(function(e) {
                            delete e.rtx
                        }), i.encodings = e.recvEncodingParameters, i.rtcp = {
                            cname: e.cname
                        }, e.sendEncodingParameters.length && (i.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(i))
                    }, window.RTCPeerConnection.prototype.setLocalDescription = function(e) {
                        var t, n, i = this;
                        if ("offer" === e.type) this._pendingOffer && (t = r.splitSections(e.sdp), n = t.shift(), t.forEach(function(e, t) {
                            var n = r.parseRtpParameters(e);
                            i._pendingOffer[t].localCapabilities = n
                        }), this.transceivers = this._pendingOffer, delete this._pendingOffer);
                        else if ("answer" === e.type) {
                            t = r.splitSections(i.remoteDescription.sdp), n = t.shift();
                            var a = r.matchPrefix(n, "a=ice-lite").length > 0;
                            t.forEach(function(e, t) {
                                var o = i.transceivers[t],
                                    s = o.iceGatherer,
                                    c = o.iceTransport,
                                    d = o.dtlsTransport,
                                    p = o.localCapabilities,
                                    u = o.remoteCapabilities,
                                    f = "0" === e.split("\n", 1)[0].split(" ", 2)[1];
                                if (!f && !o.isDatachannel) {
                                    var l = r.getIceParameters(e, n);
                                    if (a) {
                                        var m = r.matchPrefix(e, "a=candidate:").map(function(e) {
                                            return r.parseCandidate(e)
                                        }).filter(function(e) {
                                            return "1" === e.component
                                        });
                                        m.length && c.setRemoteCandidates(m)
                                    }
                                    var h = r.getDtlsParameters(e, n);
                                    a && (h.role = "server"), i.usingBundle && 0 !== t || (c.start(s, l, a ? "controlling" : "controlled"), d.start(h));
                                    var v = i._getCommonCapabilities(p, u);
                                    i._transceive(o, v.codecs.length > 0, !1)
                                }
                            })
                        }
                        switch (this.localDescription = {
                            type: e.type,
                            sdp: e.sdp
                        }, e.type) {
                            case "offer":
                                this._updateSignalingState("have-local-offer");
                                break;
                            case "answer":
                                this._updateSignalingState("stable");
                                break;
                            default:
                                throw new TypeError('unsupported type "' + e.type + '"')
                        }
                        var o = arguments.length > 1 && "function" == typeof arguments[1];
                        if (o) {
                            var s = arguments[1];
                            window.setTimeout(function() {
                                s(), "new" === i.iceGatheringState && (i.iceGatheringState = "gathering"), i._emitBufferedCandidates()
                            }, 0)
                        }
                        var c = Promise.resolve();
                        return c.then(function() {
                            o || ("new" === i.iceGatheringState && (i.iceGatheringState = "gathering"), window.setTimeout(i._emitBufferedCandidates.bind(i), 500))
                        }), c
                    }, window.RTCPeerConnection.prototype.setRemoteDescription = function(e) {
                        var t = this,
                            n = new MediaStream,
                            i = [],
                            a = r.splitSections(e.sdp),
                            o = a.shift(),
                            s = r.matchPrefix(o, "a=ice-lite").length > 0;
                        switch (this.usingBundle = r.matchPrefix(o, "a=group:BUNDLE ").length > 0, a.forEach(function(a, c) {
                            var d = r.splitLines(a),
                                p = d[0].substr(2).split(" "),
                                u = p[0],
                                f = "0" === p[1],
                                l = r.getDirection(a, o),
                                m = r.matchPrefix(a, "a=mid:");
                            if (m = m.length ? m[0].substr(6) : r.generateIdentifier(), "application" === u && "DTLS/SCTP" === p[2]) return void(t.transceivers[c] = {
                                mid: m,
                                isDatachannel: !0
                            });
                            var h, v, g, w, C, y, T, b, P, E, S, R, k = r.parseRtpParameters(a);
                            f || (S = r.getIceParameters(a, o), R = r.getDtlsParameters(a, o), R.role = "client"), b = r.parseRtpEncodingParameters(a);
                            var O, D = r.matchPrefix(a, "a=ssrc:").map(function(e) {
                                return r.parseSsrcMedia(e)
                            }).filter(function(e) {
                                return "cname" === e.attribute
                            })[0];
                            D && (O = D.value);
                            var x = r.matchPrefix(a, "a=end-of-candidates", o).length > 0,
                                M = r.matchPrefix(a, "a=candidate:").map(function(e) {
                                    return r.parseCandidate(e)
                                }).filter(function(e) {
                                    return "1" === e.component
                                });
                            if ("offer" !== e.type || f) "answer" !== e.type || f || (h = t.transceivers[c], v = h.iceGatherer, g = h.iceTransport, w = h.dtlsTransport, C = h.rtpSender, y = h.rtpReceiver, T = h.sendEncodingParameters, P = h.localCapabilities, t.transceivers[c].recvEncodingParameters = b, t.transceivers[c].remoteCapabilities = k, t.transceivers[c].cname = O, (s || x) && M.length && g.setRemoteCandidates(M), t.usingBundle && 0 !== c || (g.start(v, S, "controlling"), w.start(R)), t._transceive(h, "sendrecv" === l || "recvonly" === l, "sendrecv" === l || "sendonly" === l), !y || "sendrecv" !== l && "sendonly" !== l ? delete h.rtpReceiver : (E = y.track, i.push([E, y]), n.addTrack(E)));
                            else {
                                var I = t.usingBundle && c > 0 ? {
                                    iceGatherer: t.transceivers[0].iceGatherer,
                                    iceTransport: t.transceivers[0].iceTransport,
                                    dtlsTransport: t.transceivers[0].dtlsTransport
                                } : t._createIceAndDtlsTransports(m, c);
                                if (x && I.iceTransport.setRemoteCandidates(M), P = RTCRtpReceiver.getCapabilities(u), P.codecs = P.codecs.filter(function(e) {
                                        return "rtx" !== e.name
                                    }), T = [{
                                        ssrc: 1001 * (2 * c + 2)
                                    }], y = new RTCRtpReceiver(I.dtlsTransport, u), E = y.track, i.push([E, y]), n.addTrack(E), t.localStreams.length > 0 && t.localStreams[0].getTracks().length >= c) {
                                    var _;
                                    "audio" === u ? _ = t.localStreams[0].getAudioTracks()[0] : "video" === u && (_ = t.localStreams[0].getVideoTracks()[0]), _ && (C = new RTCRtpSender(_, I.dtlsTransport))
                                }
                                t.transceivers[c] = {
                                    iceGatherer: I.iceGatherer,
                                    iceTransport: I.iceTransport,
                                    dtlsTransport: I.dtlsTransport,
                                    localCapabilities: P,
                                    remoteCapabilities: k,
                                    rtpSender: C,
                                    rtpReceiver: y,
                                    kind: u,
                                    mid: m,
                                    cname: O,
                                    sendEncodingParameters: T,
                                    recvEncodingParameters: b
                                }, t._transceive(t.transceivers[c], !1, "sendrecv" === l || "sendonly" === l)
                            }
                        }), this.remoteDescription = {
                            type: e.type,
                            sdp: e.sdp
                        }, e.type) {
                            case "offer":
                                this._updateSignalingState("have-remote-offer");
                                break;
                            case "answer":
                                this._updateSignalingState("stable");
                                break;
                            default:
                                throw new TypeError('unsupported type "' + e.type + '"')
                        }
                        return n.getTracks().length && (t.remoteStreams.push(n), window.setTimeout(function() {
                            var e = new Event("addstream");
                            e.stream = n, t.dispatchEvent(e), null !== t.onaddstream && window.setTimeout(function() {
                                t.onaddstream(e)
                            }, 0), i.forEach(function(r) {
                                var i = r[0],
                                    a = r[1],
                                    o = new Event("track");
                                o.track = i, o.receiver = a, o.streams = [n], t.dispatchEvent(e), null !== t.ontrack && window.setTimeout(function() {
                                    t.ontrack(o)
                                }, 0)
                            })
                        }, 0)), arguments.length > 1 && "function" == typeof arguments[1] && window.setTimeout(arguments[1], 0), Promise.resolve()
                    }, window.RTCPeerConnection.prototype.close = function() {
                        this.transceivers.forEach(function(e) {
                            e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop()
                        }), this._updateSignalingState("closed")
                    }, window.RTCPeerConnection.prototype._updateSignalingState = function(e) {
                        this.signalingState = e;
                        var t = new Event("signalingstatechange");
                        this.dispatchEvent(t), null !== this.onsignalingstatechange && this.onsignalingstatechange(t)
                    }, window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
                        var e = new Event("negotiationneeded");
                        this.dispatchEvent(e), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                    }, window.RTCPeerConnection.prototype._updateConnectionState = function() {
                        var e, t = this,
                            n = {
                                new: 0,
                                closed: 0,
                                connecting: 0,
                                checking: 0,
                                connected: 0,
                                completed: 0,
                                failed: 0
                            };
                        if (this.transceivers.forEach(function(e) {
                                n[e.iceTransport.state]++, n[e.dtlsTransport.state]++
                            }), n.connected += n.completed, e = "new", n.failed > 0 ? e = "failed" : n.connecting > 0 || n.checking > 0 ? e = "connecting" : n.disconnected > 0 ? e = "disconnected" : n.new > 0 ? e = "new" : (n.connected > 0 || n.completed > 0) && (e = "connected"), e !== t.iceConnectionState) {
                            t.iceConnectionState = e;
                            var r = new Event("iceconnectionstatechange");
                            this.dispatchEvent(r), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(r)
                        }
                    }, window.RTCPeerConnection.prototype.createOffer = function() {
                        var e = this;
                        if (this._pendingOffer) throw new Error("createOffer called while there is a pending offer.");
                        var t;
                        1 === arguments.length && "function" != typeof arguments[0] ? t = arguments[0] : 3 === arguments.length && (t = arguments[2]);
                        var n = [],
                            i = 0,
                            a = 0;
                        if (this.localStreams.length && (i = this.localStreams[0].getAudioTracks().length, a = this.localStreams[0].getVideoTracks().length), t) {
                            if (t.mandatory || t.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                            void 0 !== t.offerToReceiveAudio && (i = t.offerToReceiveAudio), void 0 !== t.offerToReceiveVideo && (a = t.offerToReceiveVideo)
                        }
                        for (this.localStreams.length && this.localStreams[0].getTracks().forEach(function(e) {
                                n.push({
                                    kind: e.kind,
                                    track: e,
                                    wantReceive: "audio" === e.kind ? i > 0 : a > 0
                                }), "audio" === e.kind ? i-- : "video" === e.kind && a--
                            }); i > 0 || a > 0;) i > 0 && (n.push({
                            kind: "audio",
                            wantReceive: !0
                        }), i--), a > 0 && (n.push({
                            kind: "video",
                            wantReceive: !0
                        }), a--);
                        var o = r.writeSessionBoilerplate(),
                            s = [];
                        n.forEach(function(t, n) {
                            var i = t.track,
                                a = t.kind,
                                o = r.generateIdentifier(),
                                c = e.usingBundle && n > 0 ? {
                                    iceGatherer: s[0].iceGatherer,
                                    iceTransport: s[0].iceTransport,
                                    dtlsTransport: s[0].dtlsTransport
                                } : e._createIceAndDtlsTransports(o, n),
                                d = RTCRtpSender.getCapabilities(a);
                            d.codecs = d.codecs.filter(function(e) {
                                return "rtx" !== e.name
                            }), d.codecs.forEach(function(e) {
                                "H264" === e.name && void 0 === e.parameters["level-asymmetry-allowed"] && (e.parameters["level-asymmetry-allowed"] = "1")
                            });
                            var p, u, f = [{
                                ssrc: 1001 * (2 * n + 1)
                            }];
                            i && (p = new RTCRtpSender(i, c.dtlsTransport)), t.wantReceive && (u = new RTCRtpReceiver(c.dtlsTransport, a)), s[n] = {
                                iceGatherer: c.iceGatherer,
                                iceTransport: c.iceTransport,
                                dtlsTransport: c.dtlsTransport,
                                localCapabilities: d,
                                remoteCapabilities: null,
                                rtpSender: p,
                                rtpReceiver: u,
                                kind: a,
                                mid: o,
                                sendEncodingParameters: f,
                                recvEncodingParameters: null
                            }
                        }), this.usingBundle && (o += "a=group:BUNDLE " + s.map(function(e) {
                            return e.mid
                        }).join(" ") + "\r\n"), n.forEach(function(t, n) {
                            var i = s[n];
                            o += r.writeMediaSection(i, i.localCapabilities, "offer", e.localStreams[0])
                        }), this._pendingOffer = s;
                        var c = new RTCSessionDescription({
                            type: "offer",
                            sdp: o
                        });
                        return arguments.length && "function" == typeof arguments[0] && window.setTimeout(arguments[0], 0, c), Promise.resolve(c)
                    }, window.RTCPeerConnection.prototype.createAnswer = function() {
                        var e = this,
                            t = r.writeSessionBoilerplate();
                        this.usingBundle && (t += "a=group:BUNDLE " + this.transceivers.map(function(e) {
                            return e.mid
                        }).join(" ") + "\r\n"), this.transceivers.forEach(function(n) {
                            if (n.isDatachannel) return void(t += "m=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:" + n.mid + "\r\n");
                            var i = e._getCommonCapabilities(n.localCapabilities, n.remoteCapabilities);
                            t += r.writeMediaSection(n, i, "answer", e.localStreams[0])
                        });
                        var n = new RTCSessionDescription({
                            type: "answer",
                            sdp: t
                        });
                        return arguments.length && "function" == typeof arguments[0] && window.setTimeout(arguments[0], 0, n), Promise.resolve(n)
                    }, window.RTCPeerConnection.prototype.addIceCandidate = function(e) {
                        if (e) {
                            var t = e.sdpMLineIndex;
                            if (e.sdpMid)
                                for (var n = 0; n < this.transceivers.length; n++)
                                    if (this.transceivers[n].mid === e.sdpMid) {
                                        t = n;
                                        break
                                    }
                            var i = this.transceivers[t];
                            if (i) {
                                var a = Object.keys(e.candidate).length > 0 ? r.parseCandidate(e.candidate) : {};
                                if ("tcp" === a.protocol && (0 === a.port || 9 === a.port)) return;
                                if ("1" !== a.component) return;
                                "endOfCandidates" === a.type && (a = {}), i.iceTransport.addRemoteCandidate(a);
                                var o = r.splitSections(this.remoteDescription.sdp);
                                o[t + 1] += (a.type ? e.candidate.trim() : "a=end-of-candidates") + "\r\n", this.remoteDescription.sdp = o.join("")
                            }
                        } else this.transceivers.forEach(function(e) {
                            e.iceTransport.addRemoteCandidate({})
                        });
                        return arguments.length > 1 && "function" == typeof arguments[1] && window.setTimeout(arguments[1], 0), Promise.resolve()
                    }, window.RTCPeerConnection.prototype.getStats = function() {
                        var e = [];
                        this.transceivers.forEach(function(t) {
                            ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(n) {
                                t[n] && e.push(t[n].getStats())
                            })
                        });
                        var t = arguments.length > 1 && "function" == typeof arguments[1] && arguments[1];
                        return new Promise(function(n) {
                            var r = new Map;
                            Promise.all(e).then(function(e) {
                                e.forEach(function(e) {
                                    Object.keys(e).forEach(function(t) {
                                        r.set(t, e[t]), r[t] = e[t]
                                    })
                                }), t && window.setTimeout(t, 0, r), n(r)
                            })
                        })
                    }
                }
            };
        e.exports = {
            shimPeerConnection: a.shimPeerConnection,
            shimGetUserMedia: n(379)
        }
    },
    378: function(e, t) {
        "use strict";
        var n = {};
        n.generateIdentifier = function() {
            return Math.random().toString(36).substr(2, 10)
        }, n.localCName = n.generateIdentifier(), n.splitLines = function(e) {
            return e.trim().split("\n").map(function(e) {
                return e.trim()
            })
        }, n.splitSections = function(e) {
            var t = e.split("\nm=");
            return t.map(function(e, t) {
                return (t > 0 ? "m=" + e : e).trim() + "\r\n"
            })
        }, n.matchPrefix = function(e, t) {
            return n.splitLines(e).filter(function(e) {
                return 0 === e.indexOf(t)
            })
        }, n.parseCandidate = function(e) {
            var t;
            t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
            for (var n = {
                    foundation: t[0],
                    component: t[1],
                    protocol: t[2].toLowerCase(),
                    priority: parseInt(t[3], 10),
                    ip: t[4],
                    port: parseInt(t[5], 10),
                    type: t[7]
                }, r = 8; r < t.length; r += 2) switch (t[r]) {
                case "raddr":
                    n.relatedAddress = t[r + 1];
                    break;
                case "rport":
                    n.relatedPort = parseInt(t[r + 1], 10);
                    break;
                case "tcptype":
                    n.tcpType = t[r + 1]
            }
            return n
        }, n.writeCandidate = function(e) {
            var t = [];
            t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.ip), t.push(e.port);
            var n = e.type;
            return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), "candidate:" + t.join(" ")
        }, n.parseRtpMap = function(e) {
            var t = e.substr(9).split(" "),
                n = {
                    payloadType: parseInt(t.shift(), 10)
                };
            return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.numChannels = 3 === t.length ? parseInt(t[2], 10) : 1, n
        }, n.writeRtpMap = function(e) {
            var t = e.payloadType;
            return void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType), "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== e.numChannels ? "/" + e.numChannels : "") + "\r\n"
        }, n.parseExtmap = function(e) {
            var t = e.substr(9).split(" ");
            return {
                id: parseInt(t[0], 10),
                uri: t[1]
            }
        }, n.writeExtmap = function(e) {
            return "a=extmap:" + (e.id || e.preferredId) + " " + e.uri + "\r\n"
        }, n.parseFmtp = function(e) {
            for (var t, n = {}, r = e.substr(e.indexOf(" ") + 1).split(";"), i = 0; i < r.length; i++) t = r[i].trim().split("="), n[t[0].trim()] = t[1];
            return n
        }, n.writeFmtp = function(e) {
            var t = "",
                n = e.payloadType;
            if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                var r = [];
                Object.keys(e.parameters).forEach(function(t) {
                    r.push(t + "=" + e.parameters[t])
                }), t += "a=fmtp:" + n + " " + r.join(";") + "\r\n"
            }
            return t
        }, n.parseRtcpFb = function(e) {
            var t = e.substr(e.indexOf(" ") + 1).split(" ");
            return {
                type: t.shift(),
                parameter: t.join(" ")
            }
        }, n.writeRtcpFb = function(e) {
            var t = "",
                n = e.payloadType;
            return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(e) {
                t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
            }), t
        }, n.parseSsrcMedia = function(e) {
            var t = e.indexOf(" "),
                n = {
                    ssrc: parseInt(e.substr(7, t - 7), 10)
                },
                r = e.indexOf(":", t);
            return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n
        }, n.getDtlsParameters = function(e, t) {
            var r = n.splitLines(e);
            r = r.concat(n.splitLines(t));
            var i = r.filter(function(e) {
                    return 0 === e.indexOf("a=fingerprint:")
                })[0].substr(14),
                a = {
                    role: "auto",
                    fingerprints: [{
                        algorithm: i.split(" ")[0],
                        value: i.split(" ")[1]
                    }]
                };
            return a
        }, n.writeDtlsParameters = function(e, t) {
            var n = "a=setup:" + t + "\r\n";
            return e.fingerprints.forEach(function(e) {
                n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
            }), n
        }, n.getIceParameters = function(e, t) {
            var r = n.splitLines(e);
            r = r.concat(n.splitLines(t));
            var i = {
                usernameFragment: r.filter(function(e) {
                    return 0 === e.indexOf("a=ice-ufrag:");
                })[0].substr(12),
                password: r.filter(function(e) {
                    return 0 === e.indexOf("a=ice-pwd:")
                })[0].substr(10)
            };
            return i
        }, n.writeIceParameters = function(e) {
            return "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"
        }, n.parseRtpParameters = function(e) {
            for (var t = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                }, r = n.splitLines(e), i = r[0].split(" "), a = 3; a < i.length; a++) {
                var o = i[a],
                    s = n.matchPrefix(e, "a=rtpmap:" + o + " ")[0];
                if (s) {
                    var c = n.parseRtpMap(s),
                        d = n.matchPrefix(e, "a=fmtp:" + o + " ");
                    switch (c.parameters = d.length ? n.parseFmtp(d[0]) : {}, c.rtcpFeedback = n.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(n.parseRtcpFb), t.codecs.push(c), c.name.toUpperCase()) {
                        case "RED":
                        case "ULPFEC":
                            t.fecMechanisms.push(c.name.toUpperCase())
                    }
                }
            }
            return n.matchPrefix(e, "a=extmap:").forEach(function(e) {
                t.headerExtensions.push(n.parseExtmap(e))
            }), t
        }, n.writeRtpDescription = function(e, t) {
            var r = "";
            return r += "m=" + e + " ", r += t.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += t.codecs.map(function(e) {
                return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType
            }).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach(function(e) {
                r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e)
            }), r += "a=rtcp-mux\r\n", t.headerExtensions.forEach(function(e) {
                r += n.writeExtmap(e)
            }), r
        }, n.parseRtpEncodingParameters = function(e) {
            var t, r = [],
                i = n.parseRtpParameters(e),
                a = i.fecMechanisms.indexOf("RED") !== -1,
                o = i.fecMechanisms.indexOf("ULPFEC") !== -1,
                s = n.matchPrefix(e, "a=ssrc:").map(function(e) {
                    return n.parseSsrcMedia(e)
                }).filter(function(e) {
                    return "cname" === e.attribute
                }),
                c = s.length > 0 && s[0].ssrc,
                d = n.matchPrefix(e, "a=ssrc-group:FID").map(function(e) {
                    var t = e.split(" ");
                    return t.shift(), t.map(function(e) {
                        return parseInt(e, 10)
                    })
                });
            d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), i.codecs.forEach(function(e) {
                if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                    var n = {
                        ssrc: c,
                        codecPayloadType: parseInt(e.parameters.apt, 10),
                        rtx: {
                            payloadType: e.payloadType,
                            ssrc: t
                        }
                    };
                    r.push(n), a && (n = JSON.parse(JSON.stringify(n)), n.fec = {
                        ssrc: t,
                        mechanism: o ? "red+ulpfec" : "red"
                    }, r.push(n))
                }
            }), 0 === r.length && c && r.push({
                ssrc: c
            });
            var p = n.matchPrefix(e, "b=");
            return p.length && (0 === p[0].indexOf("b=TIAS:") ? p = parseInt(p[0].substr(7), 10) : 0 === p[0].indexOf("b=AS:") && (p = parseInt(p[0].substr(5), 10)), r.forEach(function(e) {
                e.maxBitrate = p
            })), r
        }, n.writeSessionBoilerplate = function() {
            return "v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        }, n.writeMediaSection = function(e, t, r, i) {
            var a = n.writeRtpDescription(e.kind, t);
            if (a += n.writeIceParameters(e.iceGatherer.getLocalParameters()), a += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === r ? "actpass" : "active"), a += "a=mid:" + e.mid + "\r\n", a += e.rtpSender && e.rtpReceiver ? "a=sendrecv\r\n" : e.rtpSender ? "a=sendonly\r\n" : e.rtpReceiver ? "a=recvonly\r\n" : "a=inactive\r\n", e.rtpSender) {
                var o = "msid:" + i.id + " " + e.rtpSender.track.id + "\r\n";
                a += "a=" + o, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + o
            }
            return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n"
        }, n.getDirection = function(e, t) {
            for (var r = n.splitLines(e), i = 0; i < r.length; i++) switch (r[i]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                    return r[i].substr(2)
            }
            return t ? n.getDirection(t) : "sendrecv"
        }, e.exports = n
    },
    379: function(e, t) {
        "use strict";
        e.exports = function() {
            var e = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name
                        }
                    }
                },
                t = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function(n) {
                return t(n).catch(function(t) {
                    return Promise.reject(e(t))
                })
            }
        }
    },
    380: function(e, t, n) {
        "use strict";
        var r = n(374).browserDetails,
            i = {
                shimOnTrack: function() {
                    "object" != typeof window || !window.RTCPeerConnection || "ontrack" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, "ontrack", {
                        get: function() {
                            return this._ontrack
                        },
                        set: function(e) {
                            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e), this.addEventListener("addstream", this._ontrackpoly = function(e) {
                                e.stream.getTracks().forEach(function(t) {
                                    var n = new Event("track");
                                    n.track = t, n.receiver = {
                                        track: t
                                    }, n.streams = [e.stream], this.dispatchEvent(n)
                                }.bind(this))
                            }.bind(this))
                        }
                    })
                },
                shimSourceObject: function() {
                    "object" == typeof window && (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this.mozSrcObject
                        },
                        set: function(e) {
                            this.mozSrcObject = e
                        }
                    }))
                },
                shimPeerConnection: function() {
                    if ("object" == typeof window && (window.RTCPeerConnection || window.mozRTCPeerConnection)) {
                        window.RTCPeerConnection || (window.RTCPeerConnection = function(e, t) {
                            if (r.version < 38 && e && e.iceServers) {
                                for (var n = [], i = 0; i < e.iceServers.length; i++) {
                                    var a = e.iceServers[i];
                                    if (a.hasOwnProperty("urls"))
                                        for (var o = 0; o < a.urls.length; o++) {
                                            var s = {
                                                url: a.urls[o]
                                            };
                                            0 === a.urls[o].indexOf("turn") && (s.username = a.username, s.credential = a.credential), n.push(s)
                                        } else n.push(e.iceServers[i])
                                }
                                e.iceServers = n
                            }
                            return new mozRTCPeerConnection(e, t)
                        }, window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype, mozRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, "generateCertificate", {
                            get: function() {
                                return mozRTCPeerConnection.generateCertificate
                            }
                        }), window.RTCSessionDescription = mozRTCSessionDescription, window.RTCIceCandidate = mozRTCIceCandidate), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
                            var t = RTCPeerConnection.prototype[e];
                            RTCPeerConnection.prototype[e] = function() {
                                return arguments[0] = new("addIceCandidate" === e ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments)
                            }
                        });
                        var e = RTCPeerConnection.prototype.addIceCandidate;
                        if (RTCPeerConnection.prototype.addIceCandidate = function() {
                                return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                            }, r.version < 48) {
                            var t = function(e) {
                                    var t = new Map;
                                    return Object.keys(e).forEach(function(n) {
                                        t.set(n, e[n]), t[n] = e[n]
                                    }), t
                                },
                                n = RTCPeerConnection.prototype.getStats;
                            RTCPeerConnection.prototype.getStats = function(e, r, i) {
                                return n.apply(this, [e || null]).then(function(e) {
                                    return t(e)
                                }).then(r, i)
                            }
                        }
                    }
                }
            };
        e.exports = {
            shimOnTrack: i.shimOnTrack,
            shimSourceObject: i.shimSourceObject,
            shimPeerConnection: i.shimPeerConnection,
            shimGetUserMedia: n(381)
        }
    },
    381: function(e, t, n) {
        "use strict";
        var r = n(374).log,
            i = n(374).browserDetails;
        e.exports = function() {
            var e = function(e) {
                    return {
                        name: {
                            SecurityError: "NotAllowedError",
                            PermissionDeniedError: "NotAllowedError"
                        }[e.name] || e.name,
                        message: {
                            "The operation is insecure.": "The request is not allowed by the user agent or the platform in the current context."
                        }[e.message] || e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                },
                t = function(t, n, a) {
                    var o = function(e) {
                        if ("object" != typeof e || e.require) return e;
                        var t = [];
                        return Object.keys(e).forEach(function(n) {
                            if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                                var r = e[n] = "object" == typeof e[n] ? e[n] : {
                                    ideal: e[n]
                                };
                                if (void 0 === r.min && void 0 === r.max && void 0 === r.exact || t.push(n), void 0 !== r.exact && ("number" == typeof r.exact ? r.min = r.max = r.exact : e[n] = r.exact, delete r.exact), void 0 !== r.ideal) {
                                    e.advanced = e.advanced || [];
                                    var i = {};
                                    "number" == typeof r.ideal ? i[n] = {
                                        min: r.ideal,
                                        max: r.ideal
                                    } : i[n] = r.ideal, e.advanced.push(i), delete r.ideal, Object.keys(r).length || delete e[n]
                                }
                            }
                        }), t.length && (e.require = t), e
                    };
                    return t = JSON.parse(JSON.stringify(t)), i.version < 38 && (r("spec: " + JSON.stringify(t)), t.audio && (t.audio = o(t.audio)), t.video && (t.video = o(t.video)), r("ff37: " + JSON.stringify(t))), navigator.mozGetUserMedia(t, n, function(t) {
                        a(e(t))
                    })
                },
                n = function(e) {
                    return new Promise(function(n, r) {
                        t(e, n, r)
                    })
                };
            if (navigator.mediaDevices || (navigator.mediaDevices = {
                    getUserMedia: n,
                    addEventListener: function() {},
                    removeEventListener: function() {}
                }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() {
                    return new Promise(function(e) {
                        var t = [{
                            kind: "audioinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }, {
                            kind: "videoinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }];
                        e(t)
                    })
                }, i.version < 41) {
                var a = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
                navigator.mediaDevices.enumerateDevices = function() {
                    return a().then(void 0, function(e) {
                        if ("NotFoundError" === e.name) return [];
                        throw e
                    })
                }
            }
            if (i.version < 49) {
                var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function(t) {
                    return o(t).then(function(e) {
                        if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) {
                            e.stop()
                        }), new DOMException("The object can not be found here.", "NotFoundError");
                        return e
                    }, function(t) {
                        return Promise.reject(e(t))
                    })
                }
            }
            navigator.getUserMedia = function(e, n, r) {
                return i.version < 44 ? t(e, n, r) : (console.warn("navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia"), void navigator.mediaDevices.getUserMedia(e).then(n, r))
            }
        }
    },
    382: function(e, t) {
        "use strict";
        var n = {
            shimGetUserMedia: function() {
                navigator.getUserMedia = navigator.webkitGetUserMedia
            }
        };
        e.exports = {
            shimGetUserMedia: n.shimGetUserMedia
        }
    },
    664: function(e, t, n) {
        "use strict";

        function r(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }

        var i = n(352),
            a = r(i);
		chrome.storage.sync.get(null, function(items) {
				var m = false;
                var c = items["cameraEnabled"] === false ? false : true ;
                var videoOptions = false;
                if(c){
                    videoOptions = {
                        width: {
                            ideal: a.default.VIDEO_WIDTH
                        },
                        height: {
                            ideal: a.default.VIDEO_HEIGHT
                        },
                        aspectRatio: 16 / 9,
                        frameRate: {
                            min: a.default.MIN_FRAME_RATE
                        }
                    }
                    if(items["video-input"]){
                        videoOptions = {
                            optional: [
                                {sourceId: items["video-input"]}
                            ]
                        }
                    }
                };
				n(373), window.navigator.mediaDevices.getUserMedia({
				audio: m,
				video: videoOptions
			}).then(function(e) {
				var t = document.querySelector("#camera-stream");
				t.srcObject = e;
        t.classList.remove('cp-camera-fadein');
        t.addEventListener('loadeddata',function(){    
          t.classList.add('cp-camera-fadein');
        })
			}).catch(function(err) {
			    console.log(err.message)
				console.log("Unable to get camera stream")
			})
		});	
    },
    665: function(e, t) {}
});
//# sourceMappingURL=camera.min.js.map